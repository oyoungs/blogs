<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CGO中处理C中的回调函数</title>
    <url>/2020/09/24/CGO%E4%B8%AD%E5%A4%84%E7%90%86C%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="CGO中处理C中的回调函数"><a href="#CGO中处理C中的回调函数" class="headerlink" title="CGO中处理C中的回调函数"></a>CGO中处理C中的回调函数</h1><h2 id="假设有以下-C语言的接口"><a href="#假设有以下-C语言的接口" class="headerlink" title="假设有以下 C语言的接口"></a>假设有以下 C语言的接口</h2><p>api.h</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> API_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> API_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IntCallback)</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetIntCallback</span><span class="params">(IntCallback cb, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoIntCallback</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>此时如果我们想要通过CGO来将上述的两个(尤其是设置回调函数的<code>SetIntCallback</code>)导入到<code>golang</code>中来使用，该怎么做呢？</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li><code>C语言</code>中的<code>void *</code>与 <code>GO</code>中的什么类型对应呢？</li>
<li><code>C语言</code>中的函数指针与<code>GO</code>中的函数怎么对应呢？</li>
</ul>
<h2 id="思考结果如下"><a href="#思考结果如下" class="headerlink" title="思考结果如下"></a>思考结果如下</h2><ul>
<li><code>C语言</code>中的 <code>void *</code>和 <code>Go</code>中的<code>unsafe.Pointer</code>对应</li>
<li><code>C语言</code>中的函数和 <code>Go</code>中的函数可以通过 <code>//export NAME</code>的方式来建立对应关系</li>
</ul>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><h3 id="1-先在CGO中声明一下回调函数需要用到的C函数"><a href="#1-先在CGO中声明一下回调函数需要用到的C函数" class="headerlink" title="1. 先在CGO中声明一下回调函数需要用到的C函数"></a>1. 先在<code>CGO</code>中声明一下回调函数需要用到的<code>C函数</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include "api.h"</span></span><br><span class="line"><span class="comment">extern void cgoCall(void *, int); // 这里与api.h中的IntCallback保持类型一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在Golang中通过-export方式实现上述的C函数"><a href="#2-在Golang中通过-export方式实现上述的C函数" class="headerlink" title="2. 在Golang中通过 //export方式实现上述的C函数"></a>2. 在<code>Golang</code>中通过 <code>//export</code>方式实现上述的<code>C函数</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处省略上述重复代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export cgoCall</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cgoCall</span><span class="params">(p unsafe.Pointer, number C.<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 这里先留空，我们还没确定传进来的 p是什么具体类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-在Golang中定义一个interface来接收上面的函数里的C-int类型的参数"><a href="#3-在Golang中定义一个interface来接收上面的函数里的C-int类型的参数" class="headerlink" title="3. 在Golang中定义一个interface来接收上面的函数里的C.int类型的参数"></a>3. 在<code>Golang</code>中定义一个<code>interface</code>来接收上面的函数里的<code>C.int</code>类型的参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处省略上述重复代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Caller <span class="keyword">interface</span> &#123;</span><br><span class="line">	Call(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们可以将<code>Caller类型</code>作为<code>步骤2</code>中的p传进去作为参数了</p>
<h3 id="4-在完善一下步骤2中的cgoCall"><a href="#4-在完善一下步骤2中的cgoCall" class="headerlink" title="4. 在完善一下步骤2中的cgoCall"></a>4. 在完善一下<code>步骤2</code>中的<code>cgoCall</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处省略上述重复代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//export cgoCall</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cgoCall</span><span class="params">(p unsafe.Pointer, number C.<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	caller := *(*Caller)(p)</span><br><span class="line">	caller.Call(<span class="keyword">int</span>(number))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明:<br>我们在这里将<code>p</code>参数转化为 一个 <code>Caller</code>的<code>interface</code>类型，再调用 <code>Caller</code>类型的<code>Call(int)</code>函数。表明我们在调用 <code>C语言</code>中的<code>SetIntCallback</code>时， <code>data</code>参数给的是一个 <code>Caller</code>类型的指针</p>
<h3 id="5-定义一个具体的类型实现-Caller接口测试一下"><a href="#5-定义一个具体的类型实现-Caller接口测试一下" class="headerlink" title="5. 定义一个具体的类型实现 Caller接口测试一下"></a>5. 定义一个具体的类型实现 Caller接口测试一下</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处省略上述重复代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OneCaller <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> AnotherCaller <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o OneCaller)</span> <span class="title">Call</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"one:"</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o AnotherCaller)</span> <span class="title">Call</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"another:"</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCallback</span><span class="params">(caller Caller)</span></span> &#123;</span><br><span class="line">	C.SetIntCallback(C.IntCallback(C.cgoCall), unsafe.Pointer(&amp;caller))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoCallback</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	C.DoIntCallback(C.<span class="keyword">int</span>(value))</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	one := OneCaller &#123;&#125;</span><br><span class="line"></span><br><span class="line">	SetCallback(one)	</span><br><span class="line">	DoCallback(<span class="number">1234</span>)</span><br><span class="line">	another := AnotherCaller &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	SetCallback(another)	</span><br><span class="line">	DoCallback(<span class="number">5678</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的运行测试一下， 发现可以输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">one: 1234</span><br><span class="line">another: 5678</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了使用<code>C语言</code>中的回调函数, 我们使用到了以下技术来实现</p>
<ul>
<li>unsafe.Pointer：将<code>Go</code>中的指针传入到<code>C语言</code>中的 <code>void *</code></li>
<li>//export XXX: 在<code>GO</code> 中实现 <code>C语言</code>中声明的函数</li>
<li>通过<code>interface</code>技术将 <code>C语言</code>中的回调函数类型绑定实现了<code>多态</code>或<code>泛型</code></li>
</ul>
]]></content>
      <tags>
        <tag>CGO</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>CGO 中对C语言的void *和void **的处理</title>
    <url>/2020/09/24/CGO-%E4%B8%AD%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84void-%E5%92%8Cvoid-%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="CGO-中对C语言的void-和void-的处理"><a href="#CGO-中对C语言的void-和void-的处理" class="headerlink" title="CGO 中对C语言的void *和void **的处理"></a>CGO 中对C语言的<code>void *</code>和<code>void **</code>的处理</h1><h2 id="1-void-与unsafe-Pointer"><a href="#1-void-与unsafe-Pointer" class="headerlink" title="1. void *与unsafe.Pointer"></a>1. <code>void *</code>与<code>unsafe.Pointer</code></h2><ul>
<li>CGO中的 <code>unsafe.Pointer</code>与C语言中的 <code>void *</code>是对应的</li>
<li><code>Go</code>中的结构体如果要传入 <code>C语言</code>的某个函数作为参数, 可以使用 <code>unsafe.Pointer</code>来转化</li>
</ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//假设这段定义在外部C源码中对cgo不可见</span></span><br><span class="line"><span class="comment">//typedef struct User &#123;</span></span><br><span class="line"><span class="comment">//	int id;</span></span><br><span class="line"><span class="comment">//	int age;</span></span><br><span class="line"><span class="comment">//	int number;</span></span><br><span class="line"><span class="comment">//&#125; User;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void User_SetId(void *user, int id) &#123;</span></span><br><span class="line"><span class="comment">	((User *)user)-&gt;id = id;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void User_SetAge(void *user, int age) &#123;</span></span><br><span class="line"><span class="comment">	((User *)user)-&gt;age = age;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static void User_SetNumber(void *user, int number) &#123;</span></span><br><span class="line"><span class="comment">	((User *)user)-&gt;number = number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="keyword">int32</span></span><br><span class="line">	Age <span class="keyword">int32</span></span><br><span class="line">	Number <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user User</span><br><span class="line"></span><br><span class="line">	pointer := unsafe.Pointer(&amp;user)</span><br><span class="line"></span><br><span class="line">	C.User_SetId(pointer, C.<span class="keyword">int</span>(<span class="number">1</span>))</span><br><span class="line">	C.User_setAge(pointer, C.<span class="keyword">int</span>(<span class="number">25</span>))</span><br><span class="line">	C.User_setNumber(pointer, C.<span class="keyword">int</span>(<span class="number">10001</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(user)	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="2-对应的-void-只需要在现有的-void-类型-CGO中的unsafe-Pointer-的对象上取地址就可以了"><a href="#2-对应的-void-只需要在现有的-void-类型-CGO中的unsafe-Pointer-的对象上取地址就可以了" class="headerlink" title="2. 对应的 void **只需要在现有的 void *类型(CGO中的unsafe.Pointer)的对象上取地址就可以了"></a>2. 对应的 <code>void **</code>只需要在现有的 <code>void *</code>类型(CGO中的<code>unsafe.Pointer</code>)的对象上取地址就可以了</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct User &#123;</span></span><br><span class="line"><span class="comment">	int id;</span></span><br><span class="line"><span class="comment">	int age;</span></span><br><span class="line"><span class="comment">	int number;</span></span><br><span class="line"><span class="comment">&#125; User;</span></span><br><span class="line"><span class="comment">static void createUser(void **pUser) &#123;</span></span><br><span class="line"><span class="comment">	if(pUser) *pUser = malloc(sizeof(User))</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User C.User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	pointer := unsafe.Pointer(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	C.createUser(&amp;pointer)</span><br><span class="line"></span><br><span class="line">	user := (*User)(pointer)</span><br><span class="line"></span><br><span class="line">	fmt.Println(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CGO</tag>
      </tags>
  </entry>
  <entry>
    <title>CGO中的一些使用注意事项</title>
    <url>/2020/09/24/CGO%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="CGO中的一些使用注意事项"><a href="#CGO中的一些使用注意事项" class="headerlink" title="CGO中的一些使用注意事项"></a>CGO中的一些使用注意事项</h1><h2 id="1-CGO中的内容必须紧挨着import-quot-C-quot-中间不得有其他import"><a href="#1-CGO中的内容必须紧挨着import-quot-C-quot-中间不得有其他import" class="headerlink" title="1. CGO中的内容必须紧挨着import &quot;C&quot;, 中间不得有其他import"></a>1. CGO中的内容必须紧挨着<code>import &quot;C&quot;</code>, 中间不得有其他<code>import</code></h2><ul>
<li>错误示范</li>
</ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(C.puts(C.CString(<span class="string">"这是一个golang字符串"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<ul>
<li>应该改为</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(C.puts(C.CString(<span class="string">"这是一个golang字符串"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-import-“C”前面的注释与import-“C”之间不得有空行"><a href="#2-import-“C”前面的注释与import-“C”之间不得有空行" class="headerlink" title="2. import “C”前面的注释与import “C”之间不得有空行"></a>2. import “C”前面的注释与import “C”之间不得有空行</h2><ul>
<li>错误示范</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(C.puts(C.CString(<span class="string">"这是一个golang字符串"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正确应为</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(C.puts(C.CString(<span class="string">"这是一个golang字符串"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-go中无法直接使用C语言头文件中的-enum-struct和union-需要使用时，需要对相关的类型进行-typedef重定义"><a href="#3-go中无法直接使用C语言头文件中的-enum-struct和union-需要使用时，需要对相关的类型进行-typedef重定义" class="headerlink" title="3. go中无法直接使用C语言头文件中的 enum,struct和union, 需要使用时，需要对相关的类型进行 typedef重定义"></a>3. go中无法直接使用C语言头文件中的 <code>enum</code>,<code>struct</code>和<code>union</code>, 需要使用时，需要对相关的类型进行 <code>typedef</code>重定义</h2><ul>
<li>错误示范</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">enum CEnum &#123;</span></span><br><span class="line"><span class="comment"> zero,</span></span><br><span class="line"><span class="comment"> one,</span></span><br><span class="line"><span class="comment"> two,</span></span><br><span class="line"><span class="comment"> three</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">struct CStruct &#123;</span></span><br><span class="line"><span class="comment"> int number;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> cenum C.CEnum = C.zero</span><br><span class="line"> <span class="keyword">var</span> cstruct C.CStruct</span><br><span class="line"> fmt.Println(cenum, cstruct.number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正确应为</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef enum CEnum &#123;</span></span><br><span class="line"><span class="comment">	zero,</span></span><br><span class="line"><span class="comment">	one,</span></span><br><span class="line"><span class="comment">	two,</span></span><br><span class="line"><span class="comment">	three</span></span><br><span class="line"><span class="comment">&#125; CEnum;</span></span><br><span class="line"><span class="comment">typedef struct CStruct &#123;</span></span><br><span class="line"><span class="comment">	int number;</span></span><br><span class="line"><span class="comment">&#125; CStruct;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cenum C.CEnum = C.zero</span><br><span class="line">	<span class="keyword">var</span> cstruct C.CStruct</span><br><span class="line">	fmt.Println(cenum, cstruct.number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-C中的union在CGO里面表现为-N-byte类型-其中N为该union类型占用的最大字节数"><a href="#4-C中的union在CGO里面表现为-N-byte类型-其中N为该union类型占用的最大字节数" class="headerlink" title="4. C中的union在CGO里面表现为[N]byte类型(其中N为该union类型占用的最大字节数)"></a>4. C中的union在CGO里面表现为<code>[N]byte</code>类型(其中N为该union类型占用的最大字节数)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef union Val &#123;</span></span><br><span class="line"><span class="comment">	int i;</span></span><br><span class="line"><span class="comment">	float f;</span></span><br><span class="line"><span class="comment">	double d;</span></span><br><span class="line"><span class="comment">&#125; Val;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> value = C.Val &#123;<span class="number">100</span>&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="built_in">len</span>(value), value[<span class="number">0</span>]) <span class="comment">// 8 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C++小技巧: 集合(vector, list, map, set)的反向遍历</title>
    <url>/2020/09/24/C-%E5%B0%8F%E6%8A%80%E5%B7%A7-%E9%9B%86%E5%90%88-vector-list-map-set-%E7%9A%84%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="一般的正向集合遍历"><a href="#一般的正向集合遍历" class="headerlink" title="一般的正向集合遍历"></a>一般的正向集合遍历</h1><h2 id="for-index-size模式"><a href="#for-index-size模式" class="headerlink" title="for/index/size模式"></a>for/index/size模式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; collection.size(); ++i) &#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; collection[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>弊端</strong>: 只适合<code>std::vector</code>这种可以通过下标随机O(1)时间访问的集合类型</p><a id="more"></a>


<h2 id="for-begin-end-模式"><a href="#for-begin-end-模式" class="headerlink" title="for/begin/end 模式"></a>for/begin/end 模式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = collection.begin(); it != collection.end(); ++it) &#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">// std::cout &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种适合大多数的集合遍历模式</p>
<h2 id="for-in-模式-for-begin-end模式的精简版"><a href="#for-in-模式-for-begin-end模式的精简版" class="headerlink" title="for/in 模式(for/begin/end模式的精简版)"></a>for/in 模式(<code>for/begin/end</code>模式的精简版)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item: collection) &#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">// std::cout &lt;&lt; item.first &lt;&lt; ", " &lt;&lt; item.second &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种写法属于<code>C++11</code>开始出现的语法糖，只要集合(包括标准库的集合和用户自定义的集合甚至伪集合)能使用<code>for/begin/end模式</code>的遍历方式就能使用这种语法糖模式</strong></p>
<h1 id="如果想反向遍历怎么办"><a href="#如果想反向遍历怎么办" class="headerlink" title="如果想反向遍历怎么办"></a>如果想反向遍历怎么办</h1><h2 id="可能的思路"><a href="#可能的思路" class="headerlink" title="可能的思路"></a>可能的思路</h2><ul>
<li>将集合先反转再遍历：可能集合被限制为常量不可反转自身，受限</li>
<li>将集合反向拷贝再遍历: 集合数量比较庞大时，会占用大量内存，慎用</li>
<li>反向迭代器(rbegin+rend): 我觉得可以，推荐</li>
</ul>
<h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><p>示例代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = collection.rbegin(); it != collection.rend(); ++it) &#123;</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">// std::cout &lt;&lt; it-&gt;first &lt;&lt; ", " &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实用法和<code>for/begin/end模式</code>几乎一样，只是需要使用<code>rbegin</code>和<code>rend</code>来代替<code>begin</code>和<code>end</code>, <code>rbegin()</code>表示反向迭代器的开始, 也就是正向的末尾, <code>rend()</code>表示反向迭代器的末尾也就是正向迭代器的开始</p>
<h2 id="能不能使用语法糖"><a href="#能不能使用语法糖" class="headerlink" title="能不能使用语法糖"></a>能不能使用语法糖</h2><p>直接使用当然不行，但并不表示我们不能使用</p>
<p>回想下上面的一句很关键的话: <code>只要集合(包括标准库的集合和用户自定义的集合甚至伪集合)能使用(for/begin/end模式)的遍历方式就能使用这种语法糖模式</code></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>把当前集合<code>rbegin</code>和<code>rend</code>接口调用转换成另外一个对象的 <code>begin()</code>和<code>end()</code>接口调用， 并且返回的迭代器是不变的</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> oyoung &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CollectionReverse</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> iterator = <span class="keyword">typename</span> T::reverse_iterator;</span><br><span class="line">        <span class="keyword">using</span> const_iterator = <span class="keyword">typename</span> T::const_reverse_iterator;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">CollectionReverse</span><span class="params">(T&amp; col)</span></span></span><br><span class="line">            : _M_collection(col) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _M_collection.rbegin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _M_collection.rbegin();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _M_collection.rend();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _M_collection.rend();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T &amp; _M_collection;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    CollectionReverse&lt;T&gt; reverse(T&amp; col) &#123;</span><br><span class="line">        <span class="keyword">return</span> CollectionReverse&lt;T&gt;(col);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何使用呢"><a href="#如何使用呢" class="headerlink" title="如何使用呢?"></a>如何使用呢?</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi &#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mii &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">10</span>&#125;, &#123;<span class="number">1</span>, <span class="number">11</span>&#125;, &#123;<span class="number">2</span>, <span class="number">12</span>&#125;, &#123;<span class="number">3</span>, <span class="number">13</span>&#125;, &#123;<span class="number">4</span>,<span class="number">14</span>&#125;, &#123;<span class="number">5</span>,<span class="number">15</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; si &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"reversed vector: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: oyoung::reverse(vi)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"reversed list: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: oyoung::reverse(li)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"reversed map: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pair: oyoung::reverse(mii)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'('</span> &lt;&lt; pair.first &lt;&lt; <span class="string">": "</span> &lt;&lt; pair.second &lt;&lt; <span class="string">"),"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"reversed set: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: oyoung::reverse(si)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果对不对呢？ 😉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reversed vector: 5 4 3 2 1 0</span><br><span class="line">reversed list: 15 14 12 12 11 10</span><br><span class="line">reversed map: (5: 15),(4: 14),(3: 13),(2: 12),(1: 11),(0: 10),</span><br><span class="line">reversed <span class="built_in">set</span>: 5 4 3 2 1 0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>集合</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习笔记之[UInt8]/[Int8]那些事</title>
    <url>/2020/07/28/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-UInt8-%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>[UInt8]</code>是Swift中的数组类型，也是作用比较特殊的一种数组类型, 常用于底层交互与内存操作与管理。如: 字符串编解码, 充当字节缓冲区等等</p><h1 id="字符串编解码"><a href="#字符串编解码" class="headerlink" title="字符串编解码"></a>字符串编解码</h1><ul>
<li><code>[UInt8]</code>（或<code>[Int8]</code>）转 <code>String</code></li>
</ul><p><strong>String有对应的直接从<code>[UInt8]</code>或<code>[Int8]</code>转换成String的构造函数</strong></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// "这是一个字符串" 的utf8编码</span></span><br><span class="line"><span class="keyword">let</span> bytes: [<span class="type">UInt8</span>] = [<span class="number">232</span>, <span class="number">191</span>, <span class="number">153</span>, <span class="number">230</span>, <span class="number">152</span>, <span class="number">175</span>, <span class="number">228</span>, <span class="number">184</span>, <span class="number">128</span>, <span class="number">228</span>, <span class="number">184</span>, <span class="number">170</span>, <span class="number">229</span>, <span class="number">173</span>, <span class="number">151</span>, <span class="number">231</span>, <span class="number">172</span>, <span class="number">166</span>, <span class="number">228</span>, <span class="number">184</span>, <span class="number">178</span>]</span><br><span class="line"><span class="comment">/// 转换成字符串</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> msg = <span class="type">String</span>(bytes: bytes, encoding: .utf8) &#123;</span><br><span class="line">	<span class="built_in">print</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>






<ul>
<li><code>String</code> 转 <code>[UInt8]</code>(或<code>[Int8]</code>）</li>
</ul>
<p><strong><code>String</code>转<code>[UInt8]</code>或<code>[Int8]</code>时需要借助中间角色Data</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"这是一个字符串"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = msg.data(using: .utf8) &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = [<span class="type">UInt8</span>](data)</span><br><span class="line">  <span class="built_in">print</span>(bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="底层交互"><a href="#底层交互" class="headerlink" title="底层交互"></a>底层交互</h1><h2 id="1-转换到C语言中的const-char-char-void-const-void"><a href="#1-转换到C语言中的const-char-char-void-const-void" class="headerlink" title="1. 转换到C语言中的const char*, char*, void*,const void*"></a>1. 转换到C语言中的<code>const char*</code>, <code>char*</code>, <code>void*</code>,<code>const void*</code></h2><p><strong>这里的转换指的是使用同一块内存地址</strong></p>
<h3 id="指针类型对应关系"><a href="#指针类型对应关系" class="headerlink" title="指针类型对应关系"></a>指针类型对应关系</h3><table>
<thead>
<tr>
<th align="left">C语言指针类型</th>
<th align="left">swift语言指针对象类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char *</td>
<td align="left"><strong>UnsafeMutablePointer&lt;Int8&gt;</strong></td>
</tr>
<tr>
<td align="left">const char *</td>
<td align="left"><strong>UnsafePointer&lt;Int8&gt;</strong></td>
</tr>
<tr>
<td align="left">unsigned char *</td>
<td align="left"><strong>UnsafeMutablePointer&lt;UInt8&gt;</strong></td>
</tr>
<tr>
<td align="left">const unsigned char *</td>
<td align="left"><strong>UnsafePointer&lt;UInt8&gt;</strong></td>
</tr>
<tr>
<td align="left">void *</td>
<td align="left"><strong>UnsafeMutableRawPointer</strong></td>
</tr>
<tr>
<td align="left">const void *</td>
<td align="left"><strong>UnsafeRawPointer</strong></td>
</tr>
</tbody></table>
<h3 id="几种特殊的指针类型"><a href="#几种特殊的指针类型" class="headerlink" title="几种特殊的指针类型"></a>几种特殊的指针类型</h3><ul>
<li><strong>UnsafeRawBufferPointer</strong></li>
<li><strong>UnsafeMutableRawBufferPointer</strong></li>
<li><strong>UnsafeBufferPointer</strong>&lt;<strong>T</strong>&gt;</li>
<li><strong>UnsafeMutableBufferPointer</strong>&lt;<strong>T</strong>&gt;</li>
</ul>
<p><strong>这些带有Buffer的指针类型， 可以理解为对应的不带Buffer的指针类型加上了缓冲区大小</strong>, 比如:</p>
<blockquote>
<p>UnsafePointer&lt;Int&gt; 对应 const int *, 表示仅有地址</p>
<p>那UnsafeBufferPointer&lt;Int&gt;对应 const int * 加 size, 表示该地址与内存大小所对应的一块缓冲区</p>
</blockquote>
<h3 id="从-UInt8-或-Int8-转换到-const-unsigned-char-或-const-char"><a href="#从-UInt8-或-Int8-转换到-const-unsigned-char-或-const-char" class="headerlink" title="从[UInt8]或[Int8] 转换到 const unsigned char*或 const char *"></a>从<code>[UInt8]</code>或<code>[Int8]</code> 转换到 <code>const unsigned char*</code>或 <code>const char *</code></h3><p><code>[UInt8]</code> -&gt; <code>UnsafeRawBufferPointer</code> -&gt; <code>UnsafeBufferPointer&lt;UInt8&gt;</code> -&gt; <code>UnsafePointer&lt;UInt8&gt;</code> (<strong>Int8同理</strong>)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 0. 原始字节数据 8字节</span></span><br><span class="line"><span class="keyword">let</span> buffer = [<span class="type">UInt8</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="number">8</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 1. [UInt8] -&gt; UnsafeRawBufferPointer</span></span><br><span class="line"><span class="keyword">let</span> unsafeRawBufferPointer = buffer.withUnsafeBytes &#123; $<span class="number">0</span> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2. UnsafeRawBufferPointer -&gt; UnsafeBufferPointer&lt;UInt8&gt;</span></span><br><span class="line"><span class="keyword">let</span> unsafeBufferPointer = unsafeRawBufferPointer.bindMemory(to: <span class="type">UInt8</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3. UnsafeBufferPointer&lt;UInt8&gt; -&gt; UnsafePointer&lt;UInt8&gt;</span></span><br><span class="line"><span class="keyword">let</span> unsafePointer = unsafeBufferPointer.baseAddress</span><br></pre></td></tr></table></figure>

<p>其中 <code>步骤1</code>和<code>步骤2</code>可以合并</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 0. 原始字节数据 8字节</span></span><br><span class="line"><span class="keyword">let</span> buffer = [<span class="type">UInt8</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 1. [UInt8] -&gt; UnsafeBufferPointer&lt;UInt8&gt;</span></span><br><span class="line"><span class="keyword">let</span> unsafeBufferPointer = buffer.withUnsafeBufferPointer &#123;$<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2.. UnsafeBufferPointer&lt;UInt8&gt; -&gt; UnsafePointer&lt;UInt8&gt;</span></span><br><span class="line"><span class="keyword">let</span> unsafePointer = unsafeBufferPointer.baseAddress</span><br></pre></td></tr></table></figure>



<h3 id="从-UInt8-或-Int8-转换到-unsigned-char-或-char"><a href="#从-UInt8-或-Int8-转换到-unsigned-char-或-char" class="headerlink" title="从[UInt8]或[Int8]转换到 unsigned char *或 char *"></a>从<code>[UInt8]</code>或<code>[Int8]</code>转换到 <code>unsigned char *</code>或 <code>char *</code></h3><p><code>[UInt8]</code> -&gt; <code>UnsafeMutableRawBufferPointer</code> -&gt; <code>UnsafeMutableBufferPointer&lt;UInt8&gt;</code> -&gt; <code>UnsafeMutablePointer&lt;UInt8&gt;</code> (<strong>Int8同理</strong>)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 0. 原始字节数据 8字节</span></span><br><span class="line"><span class="keyword">var</span> buffer = [<span class="type">UInt8</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 1. [UInt8] -&gt; UnsafeMutableRawBufferPointer</span></span><br><span class="line"><span class="keyword">let</span> unsafeMutableRawBufferPointer = buffer.withUnsafeMutableBytes &#123; $<span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 2. UnsafeMutableRawBufferPointer -&gt; UnsafeMutableBufferPointer&lt;UInt8&gt;</span></span><br><span class="line"><span class="keyword">let</span> unsafeMutableBufferPointer = unsafeMutableRawBufferPointer.bindMemory(to: <span class="type">UInt8</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 3. UnsafeMutableBufferPointer&lt;UInt8&gt; -&gt; UnsafeMutablePointer&lt;UInt8&gt;</span></span><br><span class="line"><span class="keyword">let</span> unsafeMutablePointer = unsafeMutableBufferPointer.baseAddress</span><br></pre></td></tr></table></figure>

<p>其中的步骤1和步骤2也是可以合并的</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// [UInt8] -&gt; UnsafeMutableBufferPointer&lt;UInt8&gt;</span></span><br><span class="line"><span class="keyword">let</span> unsafeMutableBufferPointer = buffer.withUnsafeMutableBufferPointer &#123;$<span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="从-UInt8-或-Int8-转换成const-void-或者void"><a href="#从-UInt8-或-Int8-转换成const-void-或者void" class="headerlink" title="从[UInt8]或[Int8]转换成const void *或者void *"></a>从<code>[UInt8]</code>或<code>[Int8]</code>转换成<code>const void *</code>或者<code>void *</code></h3><p>在上述的步骤里, 在<code>步骤1</code>得到的<code>unsafeMutableRawBufferPointer</code>就可以通过该对象的<code>baseAddress</code>字段就能获取到对应的<code>void *</code></p>
<p>如:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 获取 const void *</span></span><br><span class="line"><span class="keyword">let</span> unsafeRawPointer = unsafeRawBufferPointer.baseAddress</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取void *</span></span><br><span class="line"><span class="keyword">let</span> unsafeMutableRawPointer = unsafeMutableRawBufferPointer.baseAddress</span><br></pre></td></tr></table></figure>



<h2 id="2-从C语言中的const-char-char-const-unsigned-char-unsigned-char-const-void-void-对应缓冲区的数据创建-Data"><a href="#2-从C语言中的const-char-char-const-unsigned-char-unsigned-char-const-void-void-对应缓冲区的数据创建-Data" class="headerlink" title="2. 从C语言中的const char * , char *, const unsigned char *, unsigned char *, const void *, void *对应缓冲区的数据创建 Data"></a>2. 从C语言中的const char * , char *, const unsigned char *, unsigned char *, const void *, void *对应缓冲区的数据创建 Data</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 这里是示例， 类型为 UnsafeMutablePointer&lt;Int8&gt;， 也就是 char *</span></span><br><span class="line"><span class="comment">/// message可能来自任何C语言的接口</span></span><br><span class="line"><span class="keyword">let</span> message = strerror(errno) </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 通过指针和大小来构造 UnsafeBufferPointer&lt;Int8&gt;</span></span><br><span class="line"><span class="keyword">let</span> unsafeBufferPointer = <span class="type">UnsafeBufferPointer</span>&lt;<span class="type">Int8</span>&gt;(start: message, <span class="built_in">count</span>: strlen(msg!))</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 构造Data</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="type">Data</span>(buffer: unsafeBufferPointer)</span><br></pre></td></tr></table></figure>

<h2 id="3-从Data得到-UInt8-或者-Int8-以及String"><a href="#3-从Data得到-UInt8-或者-Int8-以及String" class="headerlink" title="3. 从Data得到 [UInt8] 或者 [Int8]以及String"></a>3. 从<code>Data</code>得到 <code>[UInt8]</code> 或者 <code>[Int8]</code>以及String</h2><ul>
<li>Data其实内部就是[UInt8]，在大部分情况下都可以直接当成[UInt8]来使用, 字节的append，remove, insert, find等等都有相同的操作</li>
<li>但是如果需要拷贝出来一份 [UInt8]或者[Int8]，可以使用map函数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 缓冲区里的数据    </span></span><br><span class="line"><span class="keyword">let</span> data = <span class="type">Data</span>(buffer: unsafeBufferPointer)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// [UInt8]</span></span><br><span class="line"><span class="keyword">let</span> u8a = data.<span class="built_in">map</span> &#123;$<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// [Int8]</span></span><br><span class="line"><span class="keyword">let</span> s8a = data.<span class="built_in">map</span> &#123;<span class="type">Int8</span>($<span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>String也自带从data数据的构造函数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="type">String</span>(data: data, encoding: .utf8)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>SDL编程手册</title>
    <url>/2020/06/28/SDL%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>进入<a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">官网下载页面</a></p><p>找到对应平台的下载链接, 比如:</p><p><a href="https://www.libsdl.org/release/SDL2-2.0.12.dmg" target="_blank" rel="noopener">macOS平台</a> </p><p><a href="https://www.libsdl.org/release/SDL2-devel-2.0.12-VC.zip" target="_blank" rel="noopener">Windows平台Visual C++ 32/64-bit</a></p><p><a href="https://www.libsdl.org/release/SDL2-devel-2.0.12-mingw.tar.gz" target="_blank" rel="noopener">Windows平台mingw</a></p><h1 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h1><h2 id="基础接口"><a href="#基础接口" class="headerlink" title="基础接口"></a>基础接口</h2><h3 id="初始化与退出-SDL-h"><a href="#初始化与退出-SDL-h" class="headerlink" title="初始化与退出(SDL.h)"></a>初始化与退出(SDL.h)</h3><h4 id="SDL-Init"><a href="#SDL-Init" class="headerlink" title="SDL_Init"></a>SDL_Init</h4><ul>
<li>接口定义: </li>
</ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_Init</span><span class="params">(Uint32 flags)</span></span>;</span><br></pre></td></tr></table></figure><ul>
<li>功能说明</li>
</ul><a id="more"></a>








<blockquote>
<p>初始化SDL的各个子系统</p>
</blockquote>
<ul>
<li>参数说明:</li>
</ul>
<blockquote>
<p>flags:  子系统初始化使能标志位, 可以使用如下表所示枚举值进行或操作</p>
</blockquote>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>子系统</th>
</tr>
</thead>
<tbody><tr>
<td>SDL_INIT_AUDIO</td>
<td>音频子系统</td>
</tr>
<tr>
<td>SDL_INIT_EVENTS</td>
<td>事件子系统</td>
</tr>
<tr>
<td>SDL_INIT_TIMER</td>
<td>定时器子系统</td>
</tr>
<tr>
<td>SDL_INIT_VIDEO</td>
<td>图形图像子系统</td>
</tr>
<tr>
<td>SDL_INIT_JOYSTICK</td>
<td>游戏摇杆子系统</td>
</tr>
<tr>
<td>SDL_INIT_HAPTIC</td>
<td>触觉子系统</td>
</tr>
<tr>
<td>SDL_INIT_CAMECONTROLLER</td>
<td>游戏控制器子系统(包含摇杆子系统)</td>
</tr>
<tr>
<td>SDL_INIT_EVERYTHING</td>
<td>所有子系统</td>
</tr>
</tbody></table>
<ul>
<li>返回值说明:</li>
</ul>
<blockquote>
<p>0： 成功</p>
<p>&lt; 0: 失败错误码,  可以通过<code>SDL_GetError()</code>获取错误信息</p>
</blockquote>
<ul>
<li>示例代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (SDL_Init(SDL_INIT_EVERYTHING)) &#123;</span><br><span class="line">    SDL_Log(<span class="string">"SDL Initialize failed: %s"</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SDL-InitSubSystem"><a href="#SDL-InitSubSystem" class="headerlink" title="SDL_InitSubSystem"></a>SDL_InitSubSystem</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_InitSubSystem</span><span class="params">(Uint32 flags)</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>功能说明</p>
<blockquote>
<p>初始化SDL指定的子系统</p>
</blockquote>
</li>
<li><p>参数说明 (同 <a href="#SDL-Init">SDL_Init</a>)</p>
</li>
<li><p>返回值说明(同<a href="#SDL-Init">SDL_Init</a>)</p>
</li>
<li><p>示例代码</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  SDL_Init(SDL_INIT_VIDEO);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  SDL_InitSubSystem(SDL_INIT_JOYSTICK);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  SDL_Quit();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SDL-Quit"><a href="#SDL-Quit" class="headerlink" title="SDL_Quit"></a>SDL_Quit</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_Quit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>功能说明</li>
</ul>
<blockquote>
<p>清理所有初始化的的子系统</p>
</blockquote>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(SDL_Init(SDL_INIT_EVERYTHING)) &#123;</span><br><span class="line">    SDL_Log(<span class="string">"SDL Initialize failed: %s"</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  SDL_Quit();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SDL-QuitSubSystem"><a href="#SDL-QuitSubSystem" class="headerlink" title="SDL_QuitSubSystem"></a>SDL_QuitSubSystem</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_QuitSubSystem</span><span class="params">(Uint32 flags)</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>功能说明</li>
</ul>
<blockquote>
<p>关闭指定子系统</p>
</blockquote>
<ul>
<li>参数说明</li>
</ul>
<blockquote>
<p>flags: 同<a href="#SDL-Init">SDL_Init</a></p>
</blockquote>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> sdl_initialized = SDL_Init(<span class="number">0</span>) == <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (sdl_initialized <span class="keyword">and</span> SDL_InitSubSystem(SDL_INIT_VEDIO)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    SDL_QuitSubSystem(SDL_INIT_VEDIO);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// others subsysyem ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (sdl_initialized) SDL_Quit();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SDL-SetMainReady"><a href="#SDL-SetMainReady" class="headerlink" title="SDL_SetMainReady"></a>SDL_SetMainReady</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_SetMainReady</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>功能说明</li>
</ul>
<blockquote>
<p>当不使用SDL_main函数作为入口函数时, 使用此函数来规避SDL_Init失败</p>
</blockquote>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">  SDL_SetMainReady();</span><br><span class="line">  SDL_Init(SDL_INIT_EVERYTHING);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  SDL_Quit();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SDL-WasInit"><a href="#SDL-WasInit" class="headerlink" title="SDL_WasInit"></a>SDL_WasInit</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Uint32 <span class="title">SDL_WasInit</span><span class="params">(Uint32 flags)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>功能说明</li>
</ul>
<blockquote>
<p>获取已初始化的子系统掩码</p>
</blockquote>
<ul>
<li>参数说明</li>
</ul>
<blockquote>
<p>flags: 同<a href="#SDL-Init">SDL_Init</a></p>
</blockquote>
<ul>
<li>返回值说明</li>
</ul>
<blockquote>
<p>flags为0的时候， 返回所有已初始化子系统的掩码。</p>
<p>否则返回指定子系统的初始化状态</p>
</blockquote>
<h4 id="SDL-WinRTRunApp"><a href="#SDL-WinRTRunApp" class="headerlink" title="SDL_WinRTRunApp"></a>SDL_WinRTRunApp</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_WinRTRunApp</span><span class="params">(MainFunction main_func, <span class="keyword">void</span> *reserved)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>功能说明</li>
</ul>
<blockquote>
<p>初始化和启动SDL/WinRT 应用程序</p>
</blockquote>
<ul>
<li>参数说明</li>
</ul>
<blockquote>
<p>main_func: C风格的main函数的函数类型 <code>int MainFunction(int,char **)</code></p>
</blockquote>
<ul>
<li>返回值说明</li>
</ul>
<blockquote>
<p>0: 成功</p>
<p>-1： 失败, 可以通过SDL_GetError()获取错误信息</p>
</blockquote>
<h3 id="配置变量-SDL-hints-h"><a href="#配置变量-SDL-hints-h" class="headerlink" title="配置变量(SDL_hints.h)"></a>配置变量(SDL_hints.h)</h3><h3 id="错误处理-SDL-error-h"><a href="#错误处理-SDL-error-h" class="headerlink" title="错误处理(SDL_error.h)"></a>错误处理(SDL_error.h)</h3><h4 id="SDL-GetError"><a href="#SDL-GetError" class="headerlink" title="SDL_GetError()"></a>SDL_GetError()</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">SDL_GetError</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>功能说明</li>
</ul>
<blockquote>
<p>获取错误消息</p>
</blockquote>
<ul>
<li>返回值说明</li>
</ul>
<blockquote>
<p>有错误时， 返回长度非零的字符串首地址, 否则对应的字符串长度为0</p>
</blockquote>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (SDL_Init(SDL_INIT_EVERYTHING)) &#123;</span><br><span class="line">    SDL_Log(<span class="string">"SDL initialize failed: %s"</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  SDL_Quit();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SDL-ClearError"><a href="#SDL-ClearError" class="headerlink" title="SDL_ClearError()"></a>SDL_ClearError()</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_ClearError</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>功能说明</li>
</ul>
<blockquote>
<p>清除已有错误</p>
</blockquote>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> error  = SDL_GetError();</span><br><span class="line"><span class="keyword">if</span> (error[<span class="number">0</span>]) &#123;</span><br><span class="line">  SDL_Log(<span class="string">"SDL error: %s"</span>, error);</span><br><span class="line">  SDL_ClearError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SDL-SetError"><a href="#SDL-SetError" class="headerlink" title="SDL_SetError()"></a>SDL_SetError()</h4><ul>
<li>接口定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_SetError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>功能说明</li>
</ul>
<blockquote>
<p>设置错误信息</p>
</blockquote>
<ul>
<li>参数说明</li>
</ul>
<blockquote>
<p>printf() 风格的格式化输入参数</p>
</blockquote>
<ul>
<li>返回值说明</li>
</ul>
<blockquote>
<p>只返回 -1</p>
</blockquote>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SDL_SetError(<span class="string">"Invalid render mode: %d"</span>, mode);</span><br></pre></td></tr></table></figure>



<h3 id="日志处理-SDL-log-h"><a href="#日志处理-SDL-log-h" class="headerlink" title="日志处理(SDL_log.h)"></a>日志处理(SDL_log.h)</h3><h4 id="SDL-Log"><a href="#SDL-Log" class="headerlink" title="SDL_Log"></a>SDL_Log</h4><h4 id="SDL-LogCritical"><a href="#SDL-LogCritical" class="headerlink" title="SDL_LogCritical"></a>SDL_LogCritical</h4><h4 id="SDL-LogDebug"><a href="#SDL-LogDebug" class="headerlink" title="SDL_LogDebug"></a>SDL_LogDebug</h4><h4 id="SDL-LogError"><a href="#SDL-LogError" class="headerlink" title="SDL_LogError"></a>SDL_LogError</h4><h4 id="SDL-LogGetOutputFunction"><a href="#SDL-LogGetOutputFunction" class="headerlink" title="SDL_LogGetOutputFunction"></a>SDL_LogGetOutputFunction</h4><h4 id="SDL-GetPriority"><a href="#SDL-GetPriority" class="headerlink" title="SDL_GetPriority"></a>SDL_GetPriority</h4><h4 id="SDL-LogInfo"><a href="#SDL-LogInfo" class="headerlink" title="SDL_LogInfo"></a>SDL_LogInfo</h4><h4 id="SDL-LogMessage"><a href="#SDL-LogMessage" class="headerlink" title="SDL_LogMessage"></a>SDL_LogMessage</h4><h4 id="SDL-LogMessageV"><a href="#SDL-LogMessageV" class="headerlink" title="SDL_LogMessageV"></a>SDL_LogMessageV</h4><h4 id="SDL-LogResetPriorities"><a href="#SDL-LogResetPriorities" class="headerlink" title="SDL_LogResetPriorities"></a>SDL_LogResetPriorities</h4><h4 id="SDL-LogSetAllPriority"><a href="#SDL-LogSetAllPriority" class="headerlink" title="SDL_LogSetAllPriority"></a>SDL_LogSetAllPriority</h4><h4 id="SDL-LogSetOutputFunciton"><a href="#SDL-LogSetOutputFunciton" class="headerlink" title="SDL_LogSetOutputFunciton"></a>SDL_LogSetOutputFunciton</h4><h4 id="SDL-LogSetPriority"><a href="#SDL-LogSetPriority" class="headerlink" title="SDL_LogSetPriority"></a>SDL_LogSetPriority</h4><h4 id="SDL-LogVerbose"><a href="#SDL-LogVerbose" class="headerlink" title="SDL_LogVerbose"></a>SDL_LogVerbose</h4><h4 id="SDL-Warn"><a href="#SDL-Warn" class="headerlink" title="SDL_Warn"></a>SDL_Warn</h4><h3 id="断言-SDL-assert-h"><a href="#断言-SDL-assert-h" class="headerlink" title="断言(SDL_assert.h)"></a>断言(SDL_assert.h)</h3><h4 id="SDL-GetAssertionHandler"><a href="#SDL-GetAssertionHandler" class="headerlink" title="SDL_GetAssertionHandler"></a>SDL_GetAssertionHandler</h4><h4 id="SDL-GetAssertionReport"><a href="#SDL-GetAssertionReport" class="headerlink" title="SDL_GetAssertionReport"></a>SDL_GetAssertionReport</h4><h4 id="SDL-GetDefaultAssertionHandler"><a href="#SDL-GetDefaultAssertionHandler" class="headerlink" title="SDL_GetDefaultAssertionHandler"></a>SDL_GetDefaultAssertionHandler</h4><h4 id="SDL-ResetAssertionReport"><a href="#SDL-ResetAssertionReport" class="headerlink" title="SDL_ResetAssertionReport"></a>SDL_ResetAssertionReport</h4><h4 id="SDL-SetAssertionHandler"><a href="#SDL-SetAssertionHandler" class="headerlink" title="SDL_SetAssertionHandler"></a>SDL_SetAssertionHandler</h4><h4 id="SDL-TriggerBreakpoint"><a href="#SDL-TriggerBreakpoint" class="headerlink" title="SDL_TriggerBreakpoint"></a>SDL_TriggerBreakpoint</h4><h4 id="SDL-assert"><a href="#SDL-assert" class="headerlink" title="SDL_assert"></a>SDL_assert</h4><h4 id="SDL-assert-paranoid"><a href="#SDL-assert-paranoid" class="headerlink" title="SDL_assert_paranoid"></a>SDL_assert_paranoid</h4><h4 id="SDL-assert-release"><a href="#SDL-assert-release" class="headerlink" title="SDL_assert_release"></a>SDL_assert_release</h4><h3 id="版本查询-SDL-version-h"><a href="#版本查询-SDL-version-h" class="headerlink" title="版本查询(SDL_version.h)"></a>版本查询(SDL_version.h)</h3><h4 id="SDL-COMPILEDVERSION"><a href="#SDL-COMPILEDVERSION" class="headerlink" title="SDL_COMPILEDVERSION"></a>SDL_COMPILEDVERSION</h4><h4 id="SDL-GetRevision"><a href="#SDL-GetRevision" class="headerlink" title="SDL_GetRevision"></a>SDL_GetRevision</h4><h4 id="SDL-GetRevisionNumber"><a href="#SDL-GetRevisionNumber" class="headerlink" title="SDL_GetRevisionNumber"></a>SDL_GetRevisionNumber</h4><h4 id="SDL-GetVersion"><a href="#SDL-GetVersion" class="headerlink" title="SDL_GetVersion"></a>SDL_GetVersion</h4><h4 id="SDL-REVISION"><a href="#SDL-REVISION" class="headerlink" title="SDL_REVISION"></a>SDL_REVISION</h4><h4 id="SDL-VERSION"><a href="#SDL-VERSION" class="headerlink" title="SDL_VERSION"></a>SDL_VERSION</h4><h4 id="SDL-VERSIONNUM"><a href="#SDL-VERSIONNUM" class="headerlink" title="SDL_VERSIONNUM"></a>SDL_VERSIONNUM</h4><h4 id="SDL-VERSION-ATLEAST"><a href="#SDL-VERSION-ATLEAST" class="headerlink" title="SDL_VERSION_ATLEAST"></a>SDL_VERSION_ATLEAST</h4><h2 id="图形图像"><a href="#图形图像" class="headerlink" title="图形图像"></a>图形图像</h2><h3 id="显示与窗口管理-SDL-video-h"><a href="#显示与窗口管理-SDL-video-h" class="headerlink" title="显示与窗口管理(SDL_video.h)"></a>显示与窗口管理(SDL_video.h)</h3><p>SDL_CreateWindow<br>SDL_CreateWindowAndRenderer<br>SDL_CreateWindowFrom<br>SDL_DestroyWindow<br>SDL_DisableScreenSaver<br>SDL_EnableScreenSaver<br>SDL_GL_CreateContext<br>SDL_GL_DeleteContext<br>SDL_GL_ExtensionSupported<br>SDL_GL_GetAttribute<br>SDL_GL_GetCurrentContext<br>SDL_GL_GetCurrentWindow<br>SDL_GL_GetDrawableSize<br>SDL_GL_GetProcAddress<br>SDL_GL_GetSwapInterval<br>SDL_GL_LoadLibrary<br>SDL_GL_MakeCurrent<br>SDL_GL_ResetAttributes<br>SDL_GL_SetAttribute<br>SDL_GL_SetSwapInterval<br>SDL_GL_SwapWindow<br>SDL_GL_UnloadLibrary<br>SDL_GetClosestDisplayMode<br>SDL_GetCurrentDisplayMode<br>SDL_GetCurrentVideoDriver<br>SDL_GetDesktopDisplayMode<br>SDL_GetDisplayBounds<br>SDL_GetDisplayDPI<br>SDL_GetDisplayMode<br>SDL_GetDisplayName<br>SDL_GetDisplayUsableBounds<br>SDL_GetGrabbedWindow<br>SDL_GetNumDisplayModes</p>
<h3 id="2D加速渲染-SDL-render-h"><a href="#2D加速渲染-SDL-render-h" class="headerlink" title="2D加速渲染(SDL_render.h)"></a>2D加速渲染(SDL_render.h)</h3><p>SDL_ComposeCustomBlendMode<br>SDL_CreateRenderer<br>SDL_CreateSoftwareRenderer<br>SDL_CreateTexture<br>SDL_CreateTextureFromSurface<br>SDL_CreateWindowAndRenderer<br>SDL_DestroyRenderer<br>SDL_DestroyTexture<br>SDL_GL_BindTexture<br>SDL_GL_UnbindTexture<br>SDL_GetNumRenderDrivers<br>SDL_GetRenderDrawBlendMode<br>SDL_GetRenderDrawColor<br>SDL_GetRenderDriverInfo<br>SDL_GetRenderTarget<br>SDL_GetRenderer<br>SDL_GetRendererInfo<br>SDL_GetRendererOutputSize<br>SDL_GetTextureAlphaMod<br>SDL_GetTextureBlendMode<br>SDL_GetTextureColorMod<br>SDL_LockTexture<br>SDL_QueryTexture<br>SDL_RenderClear<br>SDL_RenderCopy<br>SDL_RenderCopyEx<br>SDL_RenderDrawLine<br>SDL_RenderDrawLines<br>SDL_RenderDrawPoint<br>SDL_RenderDrawPoints<br>SDL_RenderDrawRect<br>SDL_RenderDrawRects<br>SDL_RenderFillRect<br>SDL_RenderFillRects<br>SDL_RenderGetClipRect<br>SDL_RenderGetIntegerScale<br>SDL_RenderGetLogicalSize<br>SDL_RenderGetScale<br>SDL_RenderGetViewport<br>SDL_RenderIsClipEnabled<br>SDL_RenderPresent<br>SDL_RenderReadPixels<br>SDL_RenderSetClipRect<br>SDL_RenderSetIntegerScale<br>SDL_RenderSetLogicalSize<br>SDL_RenderSetScale<br>SDL_RenderSetViewport<br>SDL_RenderTargetSupported<br>SDL_SetRenderDrawBlendMode<br>SDL_SetRenderDrawColor<br>SDL_SetRenderTarget<br>SDL_SetTextureAlphaMod<br>SDL_SetTextureBlendMode<br>SDL_SetTextureColorMod<br>SDL_UnlockTexture<br>SDL_UpdateTexture<br>SDL_UpdateYUVTexture</p>
<h3 id="像素格式与转换例程-SDL-pixels-h"><a href="#像素格式与转换例程-SDL-pixels-h" class="headerlink" title="像素格式与转换例程(SDL_pixels.h)"></a>像素格式与转换例程(SDL_pixels.h)</h3><p>SDL_AllocFormat<br>SDL_AllocPalette<br>SDL_CalculateGammaRamp<br>SDL_FreeFormat<br>SDL_FreePalette<br>SDL_GetPixelFormatName<br>SDL_GetRGB<br>SDL_GetRGBA<br>SDL_MapRGB<br>SDL_MapRGBA<br>SDL_MasksToPixelFormatEnum<br>SDL_PixelFormatEnumToMasks<br>SDL_SetPaletteColors<br>SDL_SetPixelFormatPalette</p>
<h3 id="矩形操作函数-SDL-rect-h"><a href="#矩形操作函数-SDL-rect-h" class="headerlink" title="矩形操作函数(SDL_rect.h)"></a>矩形操作函数(SDL_rect.h)</h3><p>SDL_EnclosePoints<br>SDL_HasIntersection<br>SDL_IntersectRect<br>SDL_IntersectRectAndLine<br>SDL_PointInRect<br>SDL_RectEmpty<br>SDL_RectEquals<br>SDL_UnionRect</p>
<h3 id="表面创建于简单绘图-SDL-surface-h"><a href="#表面创建于简单绘图-SDL-surface-h" class="headerlink" title="表面创建于简单绘图(SDL_surface.h)"></a>表面创建于简单绘图(SDL_surface.h)</h3><p>SDL_BlitScaled<br>SDL_BlitSurface<br>SDL_ConvertPixels<br>SDL_ConvertSurface<br>SDL_ConvertSurfaceFormat<br>SDL_CreateRGBSurface<br>SDL_CreateRGBSurfaceFrom<br>SDL_CreateRGBSurfaceWithFormat<br>SDL_CreateRGBSurfaceWithFormatFrom<br>SDL_FillRect<br>SDL_FillRects<br>SDL_FreeSurface<br>SDL_GetClipRect<br>SDL_GetColorKey<br>SDL_GetSurfaceAlphaMod<br>SDL_GetSurfaceBlendMode<br>SDL_GetSurfaceColorMod<br>SDL_LoadBMP<br>SDL_LoadBMP_RW<br>SDL_LockSurface<br>SDL_LowerBlit<br>SDL_LowerBlitScaled<br>SDL_MUSTLOCK<br>SDL_SaveBMP<br>SDL_SaveBMP_RW<br>SDL_SetClipRect<br>SDL_SetColorKey<br>SDL_SetSurfaceAlphaMod<br>SDL_SetSurfaceBlendMode<br>SDL_SetSurfaceColorMod<br>SDL_SetSurfacePalette<br>SDL_SetSurfaceRLE<br>SDL_UnlockSurface</p>
<h3 id="平台相关的窗口管理-SDL-syswm-h"><a href="#平台相关的窗口管理-SDL-syswm-h" class="headerlink" title="平台相关的窗口管理(SDL_syswm.h)"></a>平台相关的窗口管理(SDL_syswm.h)</h3><p>SDL_GetWindowWMInfo</p>
<h3 id="剪贴板处理-SDL-clipboard-h"><a href="#剪贴板处理-SDL-clipboard-h" class="headerlink" title="剪贴板处理(SDL_clipboard.h)"></a>剪贴板处理(SDL_clipboard.h)</h3><p>SDL_GetClipboardText<br>SDL_HasClipboardText<br>SDL_SetClipboardText</p>
<h3 id="Vulkan支持-SDL-Vulkan-h"><a href="#Vulkan支持-SDL-Vulkan-h" class="headerlink" title="Vulkan支持(SDL_Vulkan.h)"></a>Vulkan支持(SDL_Vulkan.h)</h3><p>SDL_Vulkan_CreateSurface<br>SDL_Vulkan_GetDrawableSize<br>SDL_Vulkan_GetInstanceExtensions<br>SDL_Vulkan_GetVkInstanceProcAddr<br>SDL_Vulkan_LoadLibrary<br>SDL_Vulkan_UnloadLibrary</p>
<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><h3 id="音频设备管理、音频播放与录音-SDL-audio-h"><a href="#音频设备管理、音频播放与录音-SDL-audio-h" class="headerlink" title="音频设备管理、音频播放与录音(SDL_audio.h)"></a>音频设备管理、音频播放与录音(SDL_audio.h)</h3><p>SDL_AudioInit<br>SDL_AudioQuit<br>SDL_BuildAudioCVT<br>SDL_ClearQueuedAudio<br>SDL_CloseAudio<br>SDL_CloseAudioDevice<br>SDL_ConvertAudio<br>SDL_DequeueAudio<br>SDL_FreeWAV<br>SDL_GetAudioDeviceName<br>SDL_GetAudioDeviceStatus<br>SDL_GetAudioDriver<br>SDL_GetAudioStatus<br>SDL_GetCurrentAudioDriver<br>SDL_GetNumAudioDevices<br>SDL_GetNumAudioDrivers<br>SDL_GetQueuedAudioSize<br>SDL_LoadWAV<br>SDL_LoadWAV_RW<br>SDL_LockAudio<br>SDL_LockAudioDevice<br>SDL_MixAudio<br>SDL_MixAudioFormat<br>SDL_OpenAudio<br>SDL_OpenAudioDevice<br>SDL_PauseAudio<br>SDL_PauseAudioDevice<br>SDL_QueueAudio<br>SDL_UnlockAudio<br>SDL_UnlockAudioDevice</p>
<h2 id="系统输入事件"><a href="#系统输入事件" class="headerlink" title="系统输入事件"></a>系统输入事件</h2><h3 id="事件处理-SDL-events-h"><a href="#事件处理-SDL-events-h" class="headerlink" title="事件处理(SDL_events.h)"></a>事件处理(SDL_events.h)</h3><p>SDL_AddEventWatch<br>SDL_DelEventWatch<br>SDL_EventState<br>SDL_FilterEvents<br>SDL_FlushEvent<br>SDL_FlushEvents<br>SDL_GetEventFilter<br>SDL_GetEventState<br>SDL_GetNumTouchDevices<br>SDL_GetNumTouchFingers<br>SDL_GetTouchDevice<br>SDL_GetTouchFinger<br>SDL_HasEvent<br>SDL_HasEvents<br>SDL_LoadDollarTemplates<br>SDL_PeepEvents<br>SDL_PollEvent<br>SDL_PumpEvents<br>SDL_PushEvent<br>SDL_QuitRequested<br>SDL_RecordGesture<br>SDL_RegisterEvents<br>SDL_SaveAllDollarTemplates<br>SDL_SaveDollarTemplate<br>SDL_SetEventFilter<br>SDL_WaitEvent<br>SDL_WaitEventTimeout</p>
<h3 id="键盘支持-SDL-keyboard-h"><a href="#键盘支持-SDL-keyboard-h" class="headerlink" title="键盘支持(SDL_keyboard.h)"></a>键盘支持(SDL_keyboard.h)</h3><p>SDL_GetKeyFromName<br>SDL_GetKeyFromScancode<br>SDL_GetKeyName<br>SDL_GetKeyboardFocus<br>SDL_GetKeyboardState<br>SDL_GetModState<br>SDL_GetScancodeFromKey<br>SDL_GetScancodeFromName<br>SDL_GetScancodeName<br>SDL_HasScreenKeyboardSupport<br>SDL_IsScreenKeyboardShown<br>SDL_IsTextInputActive<br>SDL_SetModState<br>SDL_SetTextInputRect<br>SDL_StartTextInput<br>SDL_StopTextInput</p>
<h3 id="鼠标支持-SDL-mouse-h"><a href="#鼠标支持-SDL-mouse-h" class="headerlink" title="鼠标支持(SDL_mouse.h)"></a>鼠标支持(SDL_mouse.h)</h3><p>SDL_CaptureMouse<br>SDL_CreateColorCursor<br>SDL_CreateCursor<br>SDL_CreateSystemCursor<br>SDL_FreeCursor<br>SDL_GetCursor<br>SDL_GetDefaultCursor<br>SDL_GetGlobalMouseState<br>SDL_GetMouseFocus<br>SDL_GetMouseState<br>SDL_GetRelativeMouseMode<br>SDL_GetRelativeMouseState<br>SDL_SetCursor<br>SDL_SetRelativeMouseMode<br>SDL_ShowCursor<br>SDL_WarpMouseGlobal<br>SDL_WarpMouseInWindow</p>
<h3 id="游戏摇杆支持-SDL-joystick-h"><a href="#游戏摇杆支持-SDL-joystick-h" class="headerlink" title="游戏摇杆支持(SDL_joystick.h)"></a>游戏摇杆支持(SDL_joystick.h)</h3><p>SDL_JoystickClose<br>SDL_JoystickCurrentPowerLevel<br>SDL_JoystickEventState<br>SDL_JoystickFromInstanceID<br>SDL_JoystickGetAttached<br>SDL_JoystickGetAxis<br>SDL_JoystickGetBall<br>SDL_JoystickGetButton<br>SDL_JoystickGetDeviceGUID<br>SDL_JoystickGetGUID<br>SDL_JoystickGetGUIDFromString<br>SDL_JoystickGetGUIDString<br>SDL_JoystickGetHat<br>SDL_JoystickInstanceID<br>SDL_JoystickName<br>SDL_JoystickNameForIndex<br>SDL_JoystickNumAxes<br>SDL_JoystickNumBalls<br>SDL_JoystickNumButtons<br>SDL_JoystickNumHats<br>SDL_JoystickOpen<br>SDL_JoystickUpdate<br>SDL_NumJoysticks</p>
<h3 id="游戏控制器支持-SDL-gamecontroller-h"><a href="#游戏控制器支持-SDL-gamecontroller-h" class="headerlink" title="游戏控制器支持(SDL_gamecontroller.h)"></a>游戏控制器支持(SDL_gamecontroller.h)</h3><p>SDL_GameControllerAddMapping<br>SDL_GameControllerAddMappingsFromFile<br>SDL_GameControllerAddMappingsFromRW<br>SDL_GameControllerClose<br>SDL_GameControllerEventState<br>SDL_GameControllerFromInstanceID<br>SDL_GameControllerGetAttached<br>SDL_GameControllerGetAxis<br>SDL_GameControllerGetAxisFromString<br>SDL_GameControllerGetBindForAxis<br>SDL_GameControllerGetBindForButton<br>SDL_GameControllerGetButton<br>SDL_GameControllerGetButtonFromString<br>SDL_GameControllerGetJoystick<br>SDL_GameControllerGetStringForAxis<br>SDL_GameControllerGetStringForButton<br>SDL_GameControllerMapping<br>SDL_GameControllerMappingForGUID<br>SDL_GameControllerName<br>SDL_GameControllerNameForIndex<br>SDL_GameControllerOpen<br>SDL_GameControllerUpdate<br>SDL_IsGameController</p>
<h3 id="传感器-SDL-sensor-h"><a href="#传感器-SDL-sensor-h" class="headerlink" title="传感器(SDL_sensor.h)"></a>传感器(SDL_sensor.h)</h3><p>SDL_NumSensors<br>SDL_SensorClose<br>SDL_SensorFromInstanceID<br>SDL_SensorGetData<br>SDL_SensorGetDeviceInstanceID<br>SDL_SensorGetDeviceName<br>SDL_SensorGetDeviceNonPortableType<br>SDL_SensorGetDeviceType<br>SDL_SensorGetInstanceID<br>SDL_SensorGetName<br>SDL_SensorGetNonPortableType<br>SDL_SensorGetType<br>SDL_SensorOpen<br>SDL_SensorType<br>SDL_SensorUpdate</p>
<h2 id="力反馈"><a href="#力反馈" class="headerlink" title="力反馈"></a>力反馈</h2><h3 id="力反馈支持-SDL-haptic-h"><a href="#力反馈支持-SDL-haptic-h" class="headerlink" title="力反馈支持 (SDL_haptic.h)"></a>力反馈支持 (SDL_haptic.h)</h3><p>SDL_HapticClose<br>SDL_HapticDestroyEffect<br>SDL_HapticEffectSupported<br>SDL_HapticGetEffectStatus<br>SDL_HapticIndex<br>SDL_HapticName<br>SDL_HapticNewEffect<br>SDL_HapticNumAxes<br>SDL_HapticNumEffects<br>SDL_HapticNumEffectsPlaying<br>SDL_HapticOpen<br>SDL_HapticOpenFromJoystick<br>SDL_HapticOpenFromMouse<br>SDL_HapticOpened<br>SDL_HapticPause<br>SDL_HapticQuery<br>SDL_HapticRumbleInit<br>SDL_HapticRumblePlay<br>SDL_HapticRumbleStop<br>SDL_HapticRumbleSupported<br>SDL_HapticRunEffect<br>SDL_HapticSetAutocenter<br>SDL_HapticSetGain<br>SDL_HapticStopAll<br>SDL_HapticStopEffect<br>SDL_HapticUnpause<br>SDL_HapticUpdateEffect<br>SDL_JoystickIsHaptic<br>SDL_MouseIsHaptic<br>SDL_NumHaptics</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="定时器支持-SDL-timer-h"><a href="#定时器支持-SDL-timer-h" class="headerlink" title="定时器支持(SDL_timer.h)"></a>定时器支持(SDL_timer.h)</h3><p>SDL_AddTimer<br>SDL_Delay<br>SDL_GetPerformanceCounter<br>SDL_GetPerformanceFrequency<br>SDL_GetTicks<br>SDL_RemoveTimer<br>SDL_TICKS_PASSED</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程管理-SDL-thread-h"><a href="#线程管理-SDL-thread-h" class="headerlink" title="线程管理(SDL_thread.h)"></a>线程管理(SDL_thread.h)</h3><p>SDL_CreateThread<br>SDL_DetachThread<br>SDL_GetThreadID<br>SDL_GetThreadName<br>SDL_SetThreadPriority<br>SDL_TLSCreate<br>SDL_TLSGet<br>SDL_TLSSet<br>SDL_ThreadID<br>SDL_WaitThread</p>
<h3 id="线程同步-SDL-mutex-h"><a href="#线程同步-SDL-mutex-h" class="headerlink" title="线程同步(SDL_mutex.h)"></a>线程同步(SDL_mutex.h)</h3><p>SDL_CondBroadcast<br>SDL_CondSignal<br>SDL_CondWait<br>SDL_CondWaitTimeout<br>SDL_CreateCond<br>SDL_CreateMutex<br>SDL_CreateSemaphore<br>SDL_DestroyCond<br>SDL_DestroyMutex<br>SDL_DestroySemaphore<br>SDL_LockMutex<br>SDL_SemPost<br>SDL_SemTryWait<br>SDL_SemValue<br>SDL_SemWait<br>SDL_SemWaitTimeout<br>SDL_TryLockMutex<br>SDL_UnlockMutex</p>
<h3 id="原子操作-SDL-atomic-h"><a href="#原子操作-SDL-atomic-h" class="headerlink" title="原子操作(SDL_atomic.h)"></a>原子操作(SDL_atomic.h)</h3><p>SDL_AtomicAdd<br>SDL_AtomicCAS<br>SDL_AtomicCASPtr<br>SDL_AtomicDecRef<br>SDL_AtomicGet<br>SDL_AtomicGetPtr<br>SDL_AtomicIncRef<br>SDL_AtomicLock<br>SDL_AtomicSet<br>SDL_AtomicSetPtr<br>SDL_AtomicTryLock<br>SDL_AtomicUnlock<br>SDL_CompilerBarrier</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统路径-SDL-filesystem-h"><a href="#文件系统路径-SDL-filesystem-h" class="headerlink" title="文件系统路径(SDL_filesystem.h)"></a>文件系统路径(SDL_filesystem.h)</h3><p>SDL_GetBasePath<br>SDL_GetPrefPath</p>
<h3 id="文件IO抽象-SDL-rwops-h"><a href="#文件IO抽象-SDL-rwops-h" class="headerlink" title="文件IO抽象(SDL_rwops.h)"></a>文件IO抽象(SDL_rwops.h)</h3><p>SDL_AllocRW<br>SDL_FreeRW<br>SDL_RWFromConstMem<br>SDL_RWFromFP<br>SDL_RWFromFile<br>SDL_RWFromMem<br>SDL_RWclose<br>SDL_RWread<br>SDL_RWseek<br>SDL_RWsize<br>SDL_RWtell<br>SDL_RWwrite<br>SDL_ReadBE16<br>SDL_ReadBE32<br>SDL_ReadBE64<br>SDL_ReadLE16<br>SDL_ReadLE32<br>SDL_ReadLE64<br>SDL_ReadU8<br>SDL_WriteBE16<br>SDL_WriteBE32<br>SDL_WriteBE64<br>SDL_WriteLE16<br>SDL_WriteLE32<br>SDL_WriteLE64<br>SDL_WriteU8</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>SDL</tag>
      </tags>
  </entry>
  <entry>
    <title>SFML 在macOS的安装</title>
    <url>/2020/06/05/sfml-install/</url>
    <content><![CDATA[<h2 id="1-下载SFML的SDK"><a href="#1-下载SFML的SDK" class="headerlink" title="1. 下载SFML的SDK"></a>1. 下载SFML的SDK</h2><p>进入SFML官网的<a href="https://www.sfml-dev.org/download.php" target="_blank" rel="noopener">下载页</a>下载最新稳定版的SFML SDK</p><p>选择对应的版本后，找到如下的下载链接:</p><p><img src="/assets/images/sfml-download.jpg" alt></p><p>下载完成后解压到指定目录</p><h2 id="2-安装SFML-SDK的头文件和库文件"><a href="#2-安装SFML-SDK的头文件和库文件" class="headerlink" title="2. 安装SFML SDK的头文件和库文件"></a>2. 安装SFML SDK的头文件和库文件</h2><h3 id="frameworks"><a href="#frameworks" class="headerlink" title="frameworks"></a>frameworks</h3><ul>
<li>将解压目录下的Frameworks拷贝到系统目录下的 <code>/Library/Frameworks</code>（<code>/System/Library/Frameworks</code>也可以， 但不建议，这个是系统相关的框架）</li>
</ul><a id="more"></a>




<h3 id="dylib"><a href="#dylib" class="headerlink" title="dylib"></a>dylib</h3><ul>
<li>将<code>include</code>目录拷贝到 <code>/usr/local/</code>（出现合并选是, 或者拷贝<code>include</code>目录下的所有内容拷贝到<code>/usr/local/include</code>目录下）</li>
<li>将<code>lib</code>目录拷贝到<code>/usr/local</code>（出现合并选是, 或者拷贝<code>include</code>目录下的所有内容拷贝到<code>/usr/local/lib</code>目录下）</li>
</ul>
<h2 id="3-安装SFML的依赖库"><a href="#3-安装SFML的依赖库" class="headerlink" title="3. 安装SFML的依赖库"></a>3. 安装SFML的依赖库</h2><p>在SFML SDK的解压目录下， 还有个很重要的目录<code>extlibs</code></p>
<p>这个目录是 SFML SDK的依赖库所在目录(其实很人性化了，毕竟没让我们自己去导出找依赖库源码来自己build)</p>
<p>这个安装比较简单, 但是很有必要:</p>
<blockquote>
<p>将<code>extlibs</code>下的所有<code>.framework</code>拷贝到 <code>/Library/Frameworks</code>即可</p>
</blockquote>
<p><strong>其实到这已经算是安装完成了，剩下的就是在Xcode里面使用验证安装了。但SFML SDK为我们提供了一个很有帮助的Xcode插件工具，也就是SFML 的Xcode工程模板创建引导</strong></p>
<h2 id="4-安装Xcode工程模板"><a href="#4-安装Xcode工程模板" class="headerlink" title="4. 安装Xcode工程模板"></a>4. 安装Xcode工程模板</h2><p>在SFML SDK解压目录下，找到<code>templates</code>目录， 将改目录下的<code>SFML</code>目录整个拷贝到 <code>/Library/Developer/Xcode/Templates</code>下(如果<code>/Library/Developer/Xcode/Templates</code>不存在就自己创建一个)。</p>
<h2 id="5-验证安装"><a href="#5-验证安装" class="headerlink" title="5. 验证安装"></a>5. 验证安装</h2><p>我们打开Xcode, 然后创建新工程，在工程模板选择的时候，往下拉，就会看到SFML的模板了，选择该模板，一路点击下一步即可(中间肯定会有一些命名相关的需要填的，按自己喜好填就行)</p>
<p><img src="/assets/images/sfml-templates.jpg" alt></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>SFML</tag>
      </tags>
  </entry>
  <entry>
    <title>异步+超时等待的C++实现</title>
    <url>/2020/05/19/%E5%BC%82%E6%AD%A5-%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E7%9A%84C-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="异步-超时等待的C-实现与应用"><a href="#异步-超时等待的C-实现与应用" class="headerlink" title="异步+超时等待的C++实现与应用"></a>异步+超时等待的C++实现与应用</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在C++开发过程中，我们最常用的编程模式还是同步编程。原因很简单:</p><ul>
<li>流程简介明了，能明确知道程序的步骤流程</li>
<li>作用域简单，能够更好的控制作用域内对象的生命周期</li>
<li>历史原因, C++11才有的lambda表达式，是的异步编程的复杂度降低, 在此之前都比较复杂</li>
</ul><p>有了C++11以后，异步形式的接口越来越多，最基本就是 std::thread, std::async之类的接口</p><a id="more"></a>


<p>如果我们需要在某个同步流程中去处理比较耗时的操作时， 我们的同步流程就会被堵住以至于后续的流程无法继续。如果我们在编写同步流程时，能控制这段同步代码的最大耗时， 那将是一个很有效的编程模式。</p>
<p>于是 异步 + 超时等待的模式营运而生</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li><p>在C++11开始以后，我们能使用到的可以带超时等待的标准库接口都有哪些呢？</p>
<ul>
<li>std::future </li>
<li>std::condition_variable</li>
</ul>
</li>
<li><p>可以构造std::future对象的标准库接口有哪些呢？</p>
<ul>
<li>std::async</li>
<li>std::promise</li>
<li>std::packaged_task</li>
</ul>
</li>
</ul>
<h2 id="可选方案"><a href="#可选方案" class="headerlink" title="可选方案"></a>可选方案</h2><h3 id="使用std-async"><a href="#使用std-async" class="headerlink" title="使用std::async"></a>使用std::async</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> future = <span class="built_in">std</span>::async(<span class="built_in">std</span>::lauch::async, [=] &#123;</span><br><span class="line">  <span class="comment">/// 异步操作</span></span><br><span class="line">  <span class="comment">/// 此处比较耗时，省略</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (future.wait_for(<span class="number">10</span>s) == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">  <span class="comment">/// 此处为等待结果超时</span></span><br><span class="line">  <span class="comment">/// 但此处的return或者抛异常等退出作用域的行为都会导致阻塞直到异步操作完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<blockquote>
<ol>
<li><p>std::async名字虽然带有<code>async</code>但能给人很大的误导， 使用std::async的时候, 如果没有获取返回值的future对象，那该异步函数便会成为同步函数。原因是: std::async返回的future对象由于是右值，但没有左值对象来接管该对象的生命周期, 因此在调用完std::async后，该future对象会自动析构， 析构时，会发生等待操作，一直等待异步操作的返回值，因此看起来就像是同步一样(<strong>见示例代码1</strong>)</p>
</li>
<li><p>如果获取了std::async的返回值future对象， 那std::async才能叫真正的异步调用。 这样可以在发起异步操作后立马去执行其他操作，执行完了其他必要操作再使用future对象来获取异步结果(也有可能获取不到仍需等待，<strong>见示例代码2</strong>)</p>
</li>
<li><p>使用std::async的时候, 如果异步操作的时间大于等待超时的时间，那么等待超时以后return也会阻塞到异步操作完成才会完全退出作用(<strong>见示例代码3</strong>)</p>
</li>
</ol>
</blockquote>
<p>示例代码1:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals::chrono_literals;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"这里是异步操作"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"异步操作结束"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"这里是异步操作发起后的同步操作"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码1输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这里是异步操作</span><br><span class="line">异步操作结束</span><br><span class="line">这里是异步操作发起后的同步操作</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>

<p>示例代码2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> future = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"这里是异步操作"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"异步操作结束"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"这里是异步操作发起后的同步操作"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">500</span>ms);</span><br><span class="line">    <span class="keyword">auto</span> result = future.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"异步操作结果为: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码2输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这里是异步操作发起后的同步操作</span><br><span class="line">这里是异步操作</span><br><span class="line">异步操作结束</span><br><span class="line">异步操作结果为: 1000</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>

<p>示例代码3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">std</span>::chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something_with_future</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> future = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, [] &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"这里是异步操作"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">5</span>s);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"异步操作结束"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"这里是异步操作发起后的同步操作"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">500</span>ms);</span><br><span class="line">    <span class="keyword">if</span> (future.wait_for(<span class="number">1</span>s) == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"等待异步结果超时"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> result = future.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"异步操作结果为: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n = now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"还没有使用future"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    do_something_with_future();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用完future, 用时"</span> &lt;&lt; now() - n &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码3输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">还没有使用future</span><br><span class="line">这里是异步操作发起后的同步操作</span><br><span class="line">这里是异步操作</span><br><span class="line">等待异步结果超时</span><br><span class="line">异步操作结束</span><br><span class="line">使用完future, 用时5.00282s</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>

<p>说明: </p>
<blockquote>
<p> 这段代码乍一看，以为耗时是500ms，其实不然， 输出的总使用耗时是5s左右。 </p>
</blockquote>
<h2 id="使用std-promise"><a href="#使用std-promise" class="headerlink" title="使用std::promise"></a>使用std::promise</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">std</span>::chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something_with_promise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; promise;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"发起异步操作:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">/// 暂时用std::thread模拟下异步接口</span></span><br><span class="line">    <span class="built_in">std</span>::thread([&amp;] &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">5</span>s);</span><br><span class="line">        promise.set_value(<span class="number">1000</span>);</span><br><span class="line">    &#125;).detach();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> future = promise.get_future();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (future.wait_for(<span class="number">1</span>s) == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"等待异步结果超时"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result = future.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"异步操作结果为: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n = now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"开始使用promise"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        do_something_with_promise();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用完promise, 用时: "</span> &lt;&lt; now() - n &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开始使用promise</span><br><span class="line">发起异步操作:</span><br><span class="line">等待异步结果超时</span><br><span class="line">使用完promise, 用时: 1.00624s</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>



<p>代码说明:</p>
<blockquote>
<p>与std::async不同的是，std::promise拿到的future，在promise还没设置值得时候， future的析构不会被阻塞。因此如果希望等待超时以后能立马退出作用域，更推荐使用 std::promise</p>
</blockquote>
<h3 id="使用std-packaged-task"><a href="#使用std-packaged-task" class="headerlink" title="使用std::packaged_task"></a>使用std::packaged_task</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(<span class="built_in">std</span>::chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something_with_packaged_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>()&gt; task([] &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">5</span>s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"发起异步操作:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 使用std::thread模拟异步接口</span></span><br><span class="line">    <span class="built_in">std</span>::thread([&amp;] &#123;</span><br><span class="line">        task();</span><br><span class="line">    &#125;).detach();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> future = task.get_future();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (future.wait_for(<span class="number">1</span>s) == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"等待异步结果超时"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result = future.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"异步操作结果为: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n = now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"开始使用packaged_task"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        do_something_with_packaged_task();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用完packaged_task, 用时: "</span> &lt;&lt; now() - n &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">开始使用packaged_task</span><br><span class="line">发起异步操作:</span><br><span class="line">等待异步结果超时</span><br><span class="line">使用完packaged_task, 用时: 1.00114s</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: 0</span><br></pre></td></tr></table></figure>

<p>代码说明:</p>
<blockquote>
<p>其实std::packaged_task可以看成是std::function与std::promise的结合体, 可以理解为把一个 返回值为T类型的std::function的返回值存到内部的std::promise后，可以通过future获取到返回值</p>
</blockquote>
<h3 id="使用std-condition-variable"><a href="#使用std-condition-variable" class="headerlink" title="使用std::condition_variable"></a>使用std::condition_variable</h3><p>使用std::condition_variable的思路是: </p>
<blockquote>
<p>将异步操作的参数类型做一份拷贝，并和结果类型放在一起进行包装，创建一份包裹对象， 并在包裹对象内部使用 std::mutex和std::condition_variable对结果的访问加上条件限制。在包裹对象设置了结果值时，解除条件限制。因此可以利用 std::condition_variable的wait系列接口来限时等待或者无限等待结果的功能</p>
</blockquote>
<h2 id="综合使用示例代码"><a href="#综合使用示例代码" class="headerlink" title="综合使用示例代码"></a>综合使用示例代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std_srvs &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SetIntegerRequest</span> &#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SetIntegerResponse</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> success;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SetInteger</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Request = SetIntegerRequest;</span><br><span class="line">    <span class="keyword">using</span> Response = SetIntegerResponse;</span><br><span class="line">    </span><br><span class="line">    Request request;</span><br><span class="line">    Response response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> MREQ, <span class="keyword">typename</span> MRES&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Request = MREQ;</span><br><span class="line">    <span class="keyword">using</span> Response = MRES;</span><br><span class="line">    </span><br><span class="line">    Wrapper(<span class="keyword">const</span> Request&amp; req)</span><br><span class="line">        : m_request(req)</span><br><span class="line">        , m_response() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">const</span> Request&amp; <span class="title">request</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">const</span> Response&amp; <span class="title">response</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_response;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Response&amp; <span class="title">response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_response;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m_reponse_lock);</span><br><span class="line">        m_response_ready.wait(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">cv_status <span class="title">wait_for</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; duration)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m_reponse_lock);</span><br><span class="line">        <span class="keyword">return</span> m_response_ready.wait_for(lock, duration);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Clock, <span class="keyword">typename</span> Duration&gt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">cv_status <span class="title">wait_until</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::chrono::time_point&lt;Clock, Duration&gt;&amp; time_point)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m_reponse_lock);</span><br><span class="line">        <span class="keyword">return</span> m_response_ready.wait_until(lock, time_point);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m_reponse_lock);</span><br><span class="line">        m_response_ready.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Request m_request;</span><br><span class="line">    Response m_response;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::mutex m_reponse_lock;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable m_response_ready;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> MREQ, <span class="keyword">typename</span> MRES&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PromiseWrapper</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Request = MREQ;</span><br><span class="line">    <span class="keyword">using</span> Response = MRES;</span><br><span class="line">    </span><br><span class="line">    PromiseWrapper(<span class="keyword">const</span> Request&amp; req): m_request(req) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::future&lt;Response&gt; get_future() &#123;</span><br><span class="line">        <span class="keyword">return</span> m_response.get_future();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">const</span> Request&amp; <span class="title">request</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_response</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">        m_response.set_value(<span class="built_in">std</span>::move(response));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Request m_request;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;Response&gt; m_response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle</span><span class="params">(<span class="keyword">const</span> std_srvs::SetInteger::Request&amp; request, std_srvs::SetInteger::Response&amp; response)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> wrapper = <span class="built_in">std</span>::make_shared&lt;Wrapper&lt;std_srvs::SetInteger::Request, std_srvs::SetInteger::Response&gt;&gt;(request);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 这里发起异步任务</span></span><br><span class="line">    <span class="built_in">std</span>::thread([=] &#123;</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 模拟长时间，可以尝试将此处的时间和超时等待时间的长短交换看看结果</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        wrapper-&gt;response().success = <span class="literal">true</span>;</span><br><span class="line">        wrapper-&gt;response().message = <span class="string">"success"</span> + <span class="built_in">std</span>::to_string(wrapper-&gt;request().data);</span><br><span class="line">        </span><br><span class="line">        wrapper-&gt;accept(); <span class="comment">/// 接受任务结果</span></span><br><span class="line">        </span><br><span class="line">    &#125;).detach();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 这里等待异步任务的结果</span></span><br><span class="line">    <span class="keyword">if</span> (wrapper-&gt;wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>)) == <span class="built_in">std</span>::cv_status::no_timeout) &#123;</span><br><span class="line">        response = wrapper-&gt;response();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.success = <span class="literal">false</span>;</span><br><span class="line">        response.message = <span class="string">"timeout"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">promise_handle</span><span class="params">(<span class="keyword">const</span> std_srvs::SetInteger::Request&amp; request, std_srvs::SetInteger::Response&amp; response)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> wrapper = <span class="built_in">std</span>::make_shared&lt;PromiseWrapper&lt;std_srvs::SetInteger::Request, std_srvs::SetInteger::Response&gt;&gt;(request);</span><br><span class="line">    <span class="comment">/// 这里发起异步任务</span></span><br><span class="line">    <span class="built_in">std</span>::thread([=] &#123;</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 模拟长时间，可以尝试将此处的时间和超时等待时间的长短交换看看结果</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        std_srvs::SetInteger::Response r;</span><br><span class="line">        r.success = <span class="literal">true</span>;</span><br><span class="line">        r.message = <span class="string">"success"</span> + <span class="built_in">std</span>::to_string(wrapper-&gt;request().data);</span><br><span class="line">        </span><br><span class="line">        wrapper-&gt;set_response(<span class="built_in">std</span>::move(r)); <span class="comment">/// 接受任务结果</span></span><br><span class="line">        </span><br><span class="line">    &#125;).detach();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> future = wrapper-&gt;get_future();</span><br><span class="line">    <span class="keyword">if</span> (future.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>)) == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">        response.success = <span class="literal">false</span>;</span><br><span class="line">        response.message = <span class="string">"promise timeout"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response = future.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std_srvs::SetInteger srv;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"start: "</span> &lt;&lt; <span class="built_in">std</span>::chrono::system_clock::now().time_since_epoch().count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    handle(srv.request, srv.response);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"end  : "</span> &lt;&lt; <span class="built_in">std</span>::chrono::system_clock::now().time_since_epoch().count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (srv.response.success) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; srv.response.message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; srv.response.message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promise_handle_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std_srvs::SetInteger srv;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"start: "</span> &lt;&lt; <span class="built_in">std</span>::chrono::system_clock::now().time_since_epoch().count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    promise_handle(srv.request, srv.response);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"end  : "</span> &lt;&lt; <span class="built_in">std</span>::chrono::system_clock::now().time_since_epoch().count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (srv.response.success) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; srv.response.message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; srv.response.message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    handle_test();</span><br><span class="line">    promise_handle_test();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li>首先是Wrapper/PromiseWrapper类， 用于将同步处理中的请求参数进行包裹并作为异步参数。 对请求与相应进行包裹的目的，在于延长异步处理时的请求参数与相应参数的生命周期，使其在服务回调已经结束的情况下，仍旧有自己的生命周期，只有在服务结束并且异步处理也结束的情况下包裹的对象的生命周期才会结束</li>
<li>Wrapper类使用的是<code>条件变量(std::condition_variable)</code>技术来实现等待, PromiseWrapper使用的是 <code>std::promise</code>技术来实现等待</li>
<li>两个同步性质的服务处理函数handle/promise_handle，其中handle使用的是Wrapper技术， promise_handle用的是PromiseWrapper技术</li>
<li>两种方式都有一个共同点, 都可以等待制定的时间后以超时错误结束服务处理流程</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="rosservice的服务程序"><a href="#rosservice的服务程序" class="headerlink" title="rosservice的服务程序"></a>rosservice的服务程序</h3><ul>
<li>rosservice的服务程序不能阻塞，一旦阻塞，变回引起调用方连锁阻塞，会使系统进入僵死状态</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++学习历程汇总</title>
    <url>/2019/12/15/C-tutorials/</url>
    <content><![CDATA[<h1 id="预备篇"><a href="#预备篇" class="headerlink" title="预备篇"></a>预备篇</h1><h2 id="编程技术预备知识"><a href="#编程技术预备知识" class="headerlink" title="编程技术预备知识"></a>编程技术预备知识</h2><h3 id="二进制、十进制、十六进制"><a href="#二进制、十进制、十六进制" class="headerlink" title="二进制、十进制、十六进制"></a>二进制、十进制、十六进制</h3><ol>
<li><strong>十进制思想</strong>到<strong>n进制思想</strong>的转化</li>
<li><strong>二进制</strong>、<strong>十进制</strong>、<strong>十六进制</strong>的书面表示, 比如：15,  二进制: 0b00001111, 十进制: 15, 十六进制: 0x0F</li>
<li>进制之间的转化</li>
</ol><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><ol>
<li>顺序结构 </li>
<li>条件分支结构</li>
<li>循环结构</li>
</ol><h3 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h3><ol>
<li><strong>编辑器</strong>: 用来编写代码的工具，比如<code>vim</code> <code>vscode</code> <code>nodepad</code> <code>nodepad++</code> <code>sublime text</code> <code>atom</code> 等</li>
<li><strong>编译器</strong>: 用来将源码装换为库文件和可执行二进制文件的命+令行工具套件, 比如 <code>gcc</code>, <code>g++</code>, <code>cl.exe</code>, <code>clang</code>, <code>clang++</code></li>
<li>项目构建: 管理项目源码与编译生成脚本的工具软件, 比如 <code>make</code>, <code>cmake, scons</code>, <code>gradle</code>, <code>maven</code></li>
<li><strong>IDE</strong>: 集成了<code>编辑器</code>、<code>编译器调用自动化</code>和<code>项目构建自动化</code>的一种功能更强大的软件, 比如<code>QtCreator</code>, <code>XCode</code>, <code>Visual Studio</code>, <code>Clion</code>, <code>Code Blocks</code>, <code>Eclipse</code></li>
</ol><a id="more"></a>


<h2 id="C-开发环境安装"><a href="#C-开发环境安装" class="headerlink" title="C++开发环境安装"></a>C++开发环境安装</h2><h3 id="Windows平台环境安装"><a href="#Windows平台环境安装" class="headerlink" title="Windows平台环境安装"></a>Windows平台环境安装</h3><ol>
<li>winddows系统下环境安装(Visual Studio)</li>
<li>WSL(Windows Subsystem Linux)下环境安装</li>
</ol>
<h3 id="Ubuntu-linux平台-环境安装"><a href="#Ubuntu-linux平台-环境安装" class="headerlink" title="Ubuntu(linux平台)环境安装"></a>Ubuntu(linux平台)环境安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo aptitude install build-essential git cmake qtcreator</span><br></pre></td></tr></table></figure>



<h3 id="macOS平台环境安装-XCode安装"><a href="#macOS平台环境安装-XCode安装" class="headerlink" title="macOS平台环境安装(XCode安装)"></a>macOS平台环境安装(XCode安装)</h3><p>打开<code>AppStore</code>, 搜索 <code>Xcode</code>, 找到右侧的<code>Xcode</code> 点击 <code>获取</code>, 待 <code>获取</code>变为 <code>安装</code>后, 点击安装</p>
<h2 id="IDE的选择"><a href="#IDE的选择" class="headerlink" title="IDE的选择"></a>IDE的选择</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows:"></a>Windows:</h3><ul>
<li><code>Visual Studio Community/Professional/Ultimate</code> <strong>(Windows平台开发必备)</strong></li>
<li><code>Visual Studio Code</code> (跨平台可扩展的编辑器, 可以配置成像IDE一样功能强大)</li>
<li><code>QtCreator</code></li>
<li><code>Clion</code></li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h3><ul>
<li><code>Visual Studio Code</code></li>
<li><code>QtCreator</code></li>
<li><code>Clion</code></li>
<li><code>Code Blocks</code></li>
</ul>
<h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS:"></a>macOS:</h3><ul>
<li><code>XCode</code></li>
<li><code>Clion</code></li>
<li><code>Visual Studio Code</code></li>
<li><code>QtCreator</code></li>
</ul>
<h1 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><ol>
<li><p>使用一部分参数经过特定的计算规则得到特定结果(可以没有结果值)的一句话， 通每行一条语句, 英文分号(;)结尾(仅当前C/C++语言, 部分其他编程语言语句法则不一样，有的无需分号结尾， 有的可有可无)</p>
</li>
<li><p>示例:</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">和 等于 参数<span class="number">1</span> + 参数<span class="number">2</span> +...+ 参数n</span><br></pre></td></tr></table></figure>

<p>C/C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line"><span class="number">10</span> * <span class="number">5</span> / <span class="number">2</span> + <span class="number">6</span> / <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li>当我们需要临时保存记录下某个语句的结果时， 变量就应运而生了, 比如</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">10</span> * <span class="number">5</span> / <span class="number">2</span> + <span class="number">6</span> / <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>为什么要用变量呢？比如, 你有<code>100</code>元人民币, 早上买早餐用掉<code>10</code>元，中午买午餐又花掉了<code>20</code>元， 晚上没忍住多吃了点， 花了<code>50</code>， 那么请问，你早上、中午、晚上分别剩下多少钱呢？</li>
</ol>
<p>不用变量时:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 一开始100RMB</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> - <span class="number">10</span>; <span class="comment">/// 这是早上剩余的</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> - <span class="number">10</span> - <span class="number">20</span>; <span class="comment">///这是中午剩余的</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> - <span class="number">10</span> - <span class="number">20</span> - <span class="number">50</span>; <span class="comment">///这是晚上剩下的</span></span><br></pre></td></tr></table></figure>

<p>现在我们使用变量:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> total = <span class="number">100</span>; <span class="comment">/// 一开始的100RMB</span></span><br><span class="line"></span><br><span class="line">total = total - <span class="number">10</span>; <span class="comment">/// 早上用掉10元， 剩下 total - 10 , 然后在吧剩下的值记录到total， 此时的total才是真正意义上的剩下的钱</span></span><br><span class="line"></span><br><span class="line">total = total - <span class="number">20</span>; <span class="comment">/// 在早上剩下的基础上中午再花20元, 剩下的再次记录到total</span></span><br><span class="line"></span><br><span class="line">total = total - <span class="number">50</span>; <span class="comment">/// 中午剩下的钱晚上再划掉 50元</span></span><br></pre></td></tr></table></figure>

<p><strong>对比发现:</strong></p>
<ul>
<li>当没有使用变量时, 如果是在同一个概念上的数值有变动, 每次变动都要把完整的变动过程写一遍，变动的次数越多， 书写的过程越繁琐, 如此下去，简直灭绝人性</li>
<li>使用了变量以后, 我们不仅可以把变量当成我们的原始数值一样进行计算, 还能把计算的结果进行保存留到后续的变动，而且不管多少次的变动， 计算表达式的语句也能一直保持很简洁</li>
</ul>
<ol start="3">
<li><p>变量与变量有时候是会有区别的， 比如你18岁, 身高1.60米, 名字叫二愣子, 这种变量与变量之间的区别叫 <code>变量类型</code>，<code>18</code>岁: 这是个整数, <code>1.60</code>米: 这是实数，<code>二愣子</code>:这是文本也叫字符串</p>
</li>
<li><p>变量有哪些类型呢？ 基本的变量类型有以下几种:</p>
</li>
</ol>
<ul>
<li><code>整形</code>: 对应整数 </li>
<li><code>浮点型</code>: 对应实数 </li>
<li><code>布尔型</code>: 表示具有对立属性的状态, 一般可以表示为<code>真</code>/<code>假</code>, 0 &lt; 1 真， 1 == 2 假 </li>
<li><code>字符型</code>: 用来表示显示在屏幕上给我们看的文本</li>
</ul>
<ol start="5">
<li>变量类型的具体C/C++语言中的类型有哪些呢？</li>
</ol>
<ul>
<li><code>整形</code>: (unsigned ) char/short/int/long/long long</li>
<li><code>浮点型</code>: float, double</li>
<li><code>布尔型</code>: bool</li>
<li><code>字符型</code>: char , wchar</li>
</ul>
<ol start="6">
<li>有啥区别? 每种大类型里面的具体类型之间, 一般都只有存储空间和符号性的区别, 比如</li>
</ol>
<ul>
<li><code>整形</code>: </li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> (<span class="number">1</span>字节, <span class="number">-2</span>^<span class="number">7</span>~<span class="number">2</span>^<span class="number">7</span><span class="number">-1</span>), <span class="function"><span class="keyword">unsigned</span> <span class="title">char</span> <span class="params">(<span class="number">1</span>字节, <span class="number">0</span>~<span class="number">2</span>^<span class="number">8</span><span class="number">-1</span>)</span></span></span><br><span class="line">short(2字节，-2^15~2^15-1), unsigned char(2字节, 0~2^16-1)</span><br><span class="line"><span class="keyword">int</span> (<span class="number">4</span>字节, <span class="number">-2</span>^<span class="number">31</span>~ <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span>), <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">4</span>字节, <span class="number">0</span>~<span class="number">2</span>^<span class="number">32</span><span class="number">-1</span>)</span></span></span><br><span class="line">long/ unsigned long(平台相关，一般不小于4字节，不大于 long long 的字节数)</span><br><span class="line">long long (8字节， -2^63~2^63-1), unsigned long long(8字节, 0~2^64-1)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>浮点型</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span>(<span class="number">4</span>字节), <span class="keyword">double</span>(<span class="number">8</span>字节)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>布尔型</code>:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span>(<span class="number">1</span>字节), 只有两个值, <span class="literal">true</span>: 真，<span class="literal">false</span>: 假</span><br></pre></td></tr></table></figure>
<ul>
<li><code>字符型</code>(使用单引号引用起来的单个内容):<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>(<span class="number">1</span>字节): <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'0'</span> ...</span><br><span class="line">wchar_t(2字节): L'A', L'B', L'C'...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="7">
<li>基本类型之间可否转换?</li>
</ol>
<ul>
<li><code>整形</code> -&gt; <code>布尔型</code>: </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="literal">false</span></span><br><span class="line">非<span class="number">0</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>整形</code> -&gt; <code>浮点型</code>: </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> -&gt; <span class="number">0.0f</span>, <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">1.0f</span>, <span class="number">0.0</span></span><br><span class="line">n -&gt; n<span class="number">.0f</span>, n<span class="number">.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>浮点数</code> -&gt; <code>整数</code>, 直接取整数部分, 小数部分会直接丢弃， 因此可能会有精度损失, 比如<code>1.5</code>转化为<code>int</code>以后值为<code>1</code>, 并且不会有像我们数学意义上的四舍五入发生</li>
</ul>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ol>
<li>操作符分为 一元操作符、二元操作符、三元操作符, 所谓的元， 就是参数，一元表示只有一个参数…以此类推</li>
<li>一元操作符: <code>-</code>(取负, a = 1, -a = -1)  <code>~</code>(按位取反, ~0b00000000 = 0b11111111) <code>!</code>(逻辑取反, !true = false, !false = true)</li>
<li>二元操作符: <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>&lt;</code>、<code>&gt;</code> 、<code>&lt;=</code>、<code>&gt;=</code> 、<code>==</code> (相等)、<code>!=</code>(不等) 、<code>&lt;&lt;</code>(左移或者流输出)、<code>&gt;&gt;</code>(右移或者流输入) 、<code>+=</code> (自增)、<code>-=</code>(自减)、<code>*=</code> 、<code>/=</code> 、<code>&amp;</code>(位与)、<code>|</code>(位或)、<code>^</code>(异或)、<code>&amp;&amp;</code>(逻辑与)、<code>||</code>(逻辑或) 、<code>&amp;=</code> 、<code>|=</code>、<code>&lt;&lt;=</code> 、<code>&gt;&gt;=</code></li>
<li>三元操作符: <code>?:</code>(用法, 条件 ? 值1: 值2, 表达含义: 条件成立时， 返回值1， 不成立则返回值2) </li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li>如果从某些已有的值，计算得到某个结果值， 需要执行的语句超过<code>1条</code>时, 我们要怎么做呢？比如计算一个两个实数和的小数部分:</li>
</ol>
<p>如果直接把每一组都计算一遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> sum = <span class="number">1.5</span> + <span class="number">2.1</span>; <span class="comment">/// 结果为 3.6</span></span><br><span class="line"><span class="keyword">int</span> part = sum; <span class="comment">/// 自动忽略小数部分</span></span><br><span class="line"><span class="keyword">double</span> result1 = sum - part; <span class="comment">/// 3.6 - 3 = 0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///...中间还有很多组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">9.5</span> + <span class="number">0.7</span>; <span class="comment">/// 结果为 10.2</span></span><br><span class="line"><span class="keyword">int</span> part = sum; <span class="comment">/// 自动忽略小数部分</span></span><br><span class="line"><span class="keyword">double</span> resultn = sum - part; <span class="comment">/// 10.2- 10 = 0.2</span></span><br></pre></td></tr></table></figure>

<p>改为使用函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum = a + b; </span><br><span class="line">  <span class="keyword">int</span> part = sum; <span class="comment">/// 自动忽略小数部分</span></span><br><span class="line">  <span class="keyword">return</span> sum - part; <span class="comment">/// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> result1 = calc(<span class="number">1.5</span>, <span class="number">2.1</span>); <span class="comment">/// 结果0.6</span></span><br><span class="line"><span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">double</span> resultn = calc(<span class="number">9.5</span>, <span class="number">0.2</span>); <span class="comment">/// 结果时0.2</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>calc</code>便叫做函数, 所谓函数， 其实就是特定流程的多条语句的包装，使用函数可以避免编写大量重读的代码</p>
<ol start="2">
<li>函数的声明与定义</li>
</ol>
<ul>
<li>函数声明: 告知下文函数的形式, 一般可以编写成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">返回类型 函数名(参数<span class="number">1</span>类型 参数<span class="number">1</span>名称, ..., 参数n类型 参数名称)；</span><br></pre></td></tr></table></figure>
<p>比如上面的<code>calc</code>函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回类型是double, 有2个参数, 第一个参数名叫 a, double 类型, 第二个参数名叫b， 也是double类型</p>
<ul>
<li>函数定义: 函数的具体内容, 形式大致为:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">返回值 函数名(参数<span class="number">1</span>类型 参数<span class="number">1</span>名称, ... , 参数n类型 参数n名称)</span><br><span class="line">&#123;</span><br><span class="line">  具体实现细节，...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面的 <code>calc</code>函数的定义:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> sum = a + b; </span><br><span class="line">  <span class="keyword">int</span> part = sum; <span class="comment">/// 自动忽略小数部分</span></span><br><span class="line">  <span class="keyword">return</span> sum - part; <span class="comment">/// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意: 同一个函数， 只能定义一次， 但是可以在多处声明</strong></p>
<ol start="3">
<li>只有 返回值、函数名、参数的类型、个数、位置完全一致的情况下，才能被称为同一个函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 与</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="comment">// 是同一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 与</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">bool</span> b, <span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="comment">// 不是同一个函数</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在C中, 同一个函数名只能用在一个函数中，不支持使用同一个函数名字定义多个函数, 但是C++中却可以同一个函数名用于多个函数, 叫做<code>函数重载</code>， 比如:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? b: a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虽然用的函数名都是max</span></span><br><span class="line"><span class="comment">//但是</span></span><br><span class="line">max(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 与</span></span><br><span class="line">max(<span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line"><span class="comment">// 使用的不是同一个函数</span></span><br></pre></td></tr></table></figure>



<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h3 id="原生数组"><a href="#原生数组" class="headerlink" title="原生数组"></a>原生数组</h3><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h3 id="枚举、-结构体、联合体"><a href="#枚举、-结构体、联合体" class="headerlink" title="枚举、 结构体、联合体"></a>枚举、 结构体、联合体</h3><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h1 id="提高篇"><a href="#提高篇" class="headerlink" title="提高篇"></a>提高篇</h1><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle从零开始创建SpringBoot项目</title>
    <url>/2019/11/16/gradle-create-springboot/</url>
    <content><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="安装gradle"><a href="#安装gradle" class="headerlink" title="安装gradle"></a>安装<code>gradle</code></h2><ol>
<li><a href="https://gradle.org/releases" target="_blank" rel="noopener">下载</a><code>Gradle</code>的安装包(可选择<a href="https://gradle.org/next-steps/?version=6.0&format=bin" target="_blank" rel="noopener">二进制包</a>或者<a href="https://gradle.org/next-steps/?version=6.0&format=all" target="_blank" rel="noopener">完整包</a></li>
<li>解压压缩包到安装路径, 如:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~$ mkdir -p /usr/local/gradle</span><br><span class="line">~$ cd /usr/local/gradle</span><br><span class="line">~$ unzip ~/Downloads/gradle-6.0-bin.zip</span><br></pre></td></tr></table></figure></li>
<li>导入环境 </li>
</ol><a id="more"></a>
<ul>
<li>将<code>Gradle</code>的 <code>bin</code>目录添加到<code>PATH</code>环境变量<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~$ echo "export PATH=$GRADLE_HOME/bin:$PATH" &gt;&gt; ~/.bashrc # ~/.bash_profile ~/.zshrc</span><br><span class="line">~$ source ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li>或者将 <code>Gradle</code>的可执行文件软连接到 <code>/usr/local/bin</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~$ ln -s $GRADLE_HOME/bin/gradle /usr/local/bin/gradle</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>提示: <code>$GRADLE_HOME</code>指的是<code>gradle</code>解压后的目录, 比如 <code>/usr/local/gradle/6.0</code></strong></p>
<h1 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h1><h2 id="使用gradle-创建初始工程"><a href="#使用gradle-创建初始工程" class="headerlink" title="使用gradle 创建初始工程"></a>使用<code>gradle</code> 创建初始工程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Kotlin mkdir project</span><br><span class="line">➜  Kotlin cd project</span><br><span class="line">➜  project gradle init</span><br><span class="line">Configuration on demand is an incubating feature.</span><br><span class="line"></span><br><span class="line">Select type of project to generate:</span><br><span class="line">  1: basic</span><br><span class="line">  2: application</span><br><span class="line">  3: library</span><br><span class="line">  4: Gradle plugin</span><br><span class="line">Enter selection (default: basic) [1..4] 2</span><br><span class="line"></span><br><span class="line">Select implementation language:</span><br><span class="line">  1: C++</span><br><span class="line">  2: Groovy</span><br><span class="line">  3: Java</span><br><span class="line">  4: Kotlin</span><br><span class="line">  5: Swift</span><br><span class="line">Enter selection (default: Java) [1..5] 4</span><br><span class="line"></span><br><span class="line">Select build script DSL:</span><br><span class="line">  1: Groovy</span><br><span class="line">  2: Kotlin</span><br><span class="line">Enter selection (default: Kotlin) [1..2] 2</span><br><span class="line"></span><br><span class="line">Project name (default: project): app</span><br><span class="line"></span><br><span class="line">Source package (default: app): com.oyoung</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 24s</span><br><span class="line">2 actionable tasks: 2 executed</span><br><span class="line">➜  project</span><br></pre></td></tr></table></figure>

<h2 id="使用IntelliJ-Idea打开刚刚创建的项目"><a href="#使用IntelliJ-Idea打开刚刚创建的项目" class="headerlink" title="使用IntelliJ Idea打开刚刚创建的项目"></a>使用<code>IntelliJ Idea</code>打开刚刚创建的项目</h2><p><img src="/assets/images/open_gradle_proj.gif" alt="在这里插入图片描述"></p>
<h1 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h1><h2 id="修改build-gradle-kts文件"><a href="#修改build-gradle-kts文件" class="headerlink" title="修改build.gradle.kts文件"></a>修改<code>build.gradle.kts</code>文件</h2><ol>
<li>简化<code>kotlin</code>相关的依赖导入<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// Align versions of all Kotlin components</span></span><br><span class="line">  implementation(platform(<span class="string">"org.jetbrains.kotlin:kotlin-bom"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the Kotlin JDK 8 standard library.</span></span><br><span class="line">  implementation(<span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jdk8"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the Kotlin test library.</span></span><br><span class="line">  testImplementation(<span class="string">"org.jetbrains.kotlin:kotlin-test"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use the Kotlin JUnit integration.</span></span><br><span class="line">  testImplementation(<span class="string">"org.jetbrains.kotlin:kotlin-test-junit"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
改为<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation(kotlin(<span class="string">"stdlib"</span>, <span class="string">"1.3.50"</span>))</span><br><span class="line">  implementation(kotlin(<span class="string">"reflect"</span>, <span class="string">"1.3.50"</span>)) <span class="comment">/// kotlin 反射机制需要的库</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 暂时不需要改动</span></span><br><span class="line">  testImplementation(<span class="string">"org.jetbrains.kotlin:kotlin-test"</span>)</span><br><span class="line">  testImplementation(<span class="string">"org.jetbrains.kotlin:kotlin-test-junit"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>导入<code>springboot</code> 相关插件<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  kotlin(<span class="string">"jvm"</span>) version <span class="string">"1.3.50"</span></span><br><span class="line">  kotlin(<span class="string">"plugin.spring"</span>) version <span class="string">"1.3.50"</span>  </span><br><span class="line">  id(<span class="string">"org.springframework.boot"</span>) version <span class="string">"2.2.1.RELEASE"</span></span><br><span class="line">  id(<span class="string">"io.spring.dependency-management"</span>) version <span class="string">"1.0.8.RELEASE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中 使用 <code>kotlin()</code>方法包裹的, 属于<code>kotlin</code>模块，使用 <code>id()</code>方法的是第三方模块</li>
<li>增加 <code>mavenCentral()</code>仓库<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">  jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>导入 <code>&quot;org.springframework.boot:spring-boot-starter-web&quot;</code><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">  implementation(<span class="string">"org.springframework.boot"</span>, <span class="string">"spring-boot-starter-web"</span>)</span><br><span class="line">  <span class="comment">/// implementation("org.springframework.boot:spring-boot-starter-web")</span></span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="打开我们的程序入口App-kt"><a href="#打开我们的程序入口App-kt" class="headerlink" title="打开我们的程序入口App.kt"></a>打开我们的程序入口<code>App.kt</code></h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oyoung</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> greeting: String</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello world."</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(App().greeting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改成如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oyoung <span class="comment">/// 这里改成自己明明的包</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.runApplication</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  runApplication&lt;App&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此刻我们看到<code>runApplication</code>这一行有红色波浪线，鼠标移到上面提示:<br><img src="/assets/images/run_app_error.png" alt="错误提示"><br>这表示我们的kotlin build的字节码的jvm版本与我们实际设定的不一致</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">group = <span class="string">"com.oyoung"</span></span><br><span class="line">version = <span class="string">"0.0.1-SNAPSHOT"</span></span><br><span class="line">java.sourceCompatibility = JavaVersion.VERSION_1_8</span><br></pre></td></tr></table></figure>

<h2 id="按提示增加-jvm-target-参数"><a href="#按提示增加-jvm-target-参数" class="headerlink" title="按提示增加 -jvm-target 参数"></a>按提示增加 <code>-jvm-target</code> 参数</h2><ol>
<li>删除最下面自动生成的     <code>application</code> 任务</li>
<li>增加一个<code>KotlinCompile</code>任务<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tasks.withType&lt;KotlinCompile&gt;() &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = <span class="string">"1.8"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
建议自己敲上面的代码, 在敲代码的过程中会有一个自动导入的import 添加到文件开头<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jetbrains.kotlin.gradle.tasks.KotlinCompile</span><br></pre></td></tr></table></figure>
当然了, 如果IDE响应太慢没有自动import，也可以手动导入</li>
</ol>
<h2 id="首次尝试启动"><a href="#首次尝试启动" class="headerlink" title="首次尝试启动"></a>首次尝试启动</h2><p>打开定位为<code>App.kt</code>文件<br>在 <code>main</code> 函数的左侧, 显示行号的附近有一个<code>三角形</code>箭头, 点击, 然后会有弹出来的菜单, 之后的操作, 你懂的…<br><img src="/assets/images/run_main.png" alt="运行"></p>
<p>此时, 如果一切正常的话, 将会以默认的8080端口号启动一个没有任何路由请求的SpringBoot应用程序, 如果需要修改为自定义的端口号, 需要在<code>$PROJECT/src/main/resources</code>路径下新建一个<code>application.yml</code>(或者<code>application.properties</code>)文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">4000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第二次启动应用时 端口号即可改为自定义的端口号</li>
</ul>
<h2 id="增加controller"><a href="#增加controller" class="headerlink" title="增加controller"></a>增加controller</h2><ol>
<li>新建一个 <code>com.oyoung.controller</code>包 (或者使用自己的包前缀)</li>
<li>新建一个 <code>Controller</code>类, 比如 <code>TestController</code></li>
<li>在自定义的Controller上面添加注解 <code>@RestController</code>， 一般会自动导入 所需要的包, 没有自动导入的话, 可以按照提示按 <code>Alt + Enter</code>组合按键手动导入</li>
<li>添加第一个路由，比如 /test, 返回任意一个对象</li>
<li>重新启动程序</li>
<li>如果在上面的依赖中没有添加 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">	implementation(kotlin(<span class="string">"reflect"</span>, <span class="string">"1.3.50"</span>))</span><br><span class="line">	<span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
的话, 一般会启动失败， 至于使用什么版本, 看具体情况，我自己选择的是当前最新的稳定版<br>至此一个完整的SpringBoot初始项目就创建完成了, </li>
</ol>
<h2 id="撒花✿✿ヽ-°▽°-ノ✿"><a href="#撒花✿✿ヽ-°▽°-ノ✿" class="headerlink" title="撒花✿✿ヽ(°▽°)ノ✿"></a>撒花✿✿ヽ(°▽°)ノ✿</h2>]]></content>
      <tags>
        <tag>Gradle</tag>
        <tag>Kotlin</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>解决屏幕录制工具LICEcap在macOS 10.15 (Catalina) 无法工作问题记录</title>
    <url>/2019/11/01/licecap-not-working/</url>
    <content><![CDATA[<p>从升级macOS升级到10.15(Catalina)以后, 针对屏幕录制增加了权限管理, 所有的会录制屏幕的程序, 在首次开始录制屏幕时， 都会出现请求屏幕录制权限的弹窗</p><p>但是升级LICEcap到1.29以后, 点击 <code>record</code> 输入文件名 <strong>没带.gif后缀, 因为有文件类型 Gif (*.gif)</strong> 然后点 <code>Save</code>， 发现并没有启动屏幕录制， 重试了好几次都无效</p><a id="more"></a>

<p>这时候去看屏幕录制权限, 发现并没有勾选 LICEcap的选项, 也不能手动添加</p>
<p>于是到网上找前人经验学习, 发现有部分人的屏幕录制权限里面有LICEcap选项可以勾选</p>
<p>所以猜想: LICEcap本身肯定有什么操作是会触发系统弹窗请求屏幕录制权限的</p>
<p>搜罗了网上的各种方法, 大家都说有用的说的最多的是需要执行一条命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ xattr -d com.apple.quarantine /Applications/LICEcap.app</span><br></pre></td></tr></table></figure>

<p>我尝试输入以后发现, 问题依旧， 仍是一头雾水</p>
<p>然后试着将LICEcap点击 <code>record</code> 按钮以后的弹窗里面各个选项都分别单独启用一次, 一直都没什么变化</p>
<p>突发奇想，想到把文件名写全 (自己把文件名带上 <code>.gif</code> 后缀, 比如原来一直都用 <code>record_yyyymmdd</code> 这种格式， 然后试着写成 <code>record_yyyymmdd.gif</code>)</p>
<p><img src="/assets/images/licecap_save.png" alt="示例图"></p>
<p>此时奇迹出现, 终于弹出了 LICEcap 请求录制屏幕的警告窗口了, 但是只有拒绝和进入权限设置两个选项</p>
<p>这当然不敢拒绝啊， 点击权限设置后， 发现果然多了一个 LICEcap的勾选处于未选中状态, 而且此时….LICEcap好像已经在录制gif了</p>
<p>LICEcap真NB, 我还没授权呢， 都能直接录制了。。。就因为我 <strong>文件多输入了.gif后缀补全</strong>了？</p>
<p>此刻表示: 黑人问号尼克杨！！！</p>
<p>然后发现, 没有勾选权限的时候, 虽然能启动录制, 但是只能录制屏幕桌面壁纸</p>
<p><img src="/assets/images/licecap_not_working.gif" alt="屏幕壁纸动图"></p>
<p>勾选了权限以后, 可以录制屏幕上的内容了</p>
<p><img src="/assets/images/licecap_working.gif" alt="屏幕内容动图"></p>
<p>不过问题总算解决, 可以继续愉快的使用LICEcap录制我的动图了</p>
]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>licecap</tag>
      </tags>
  </entry>
  <entry>
    <title>解决不蒜子(busuanzi)不显示数字问题记录</title>
    <url>/2019/10/30/busuanzi/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用hexo开发个人博客时, 开启了不蒜子的统计选项， 但是在部署到Github Pages上或者本地使用serve -s 以及python -m SimpleHTTPServer的时候，经常会出现不显示数字问题<br>由于已经是使用最新的域名来下载的, 应该不存在busuanzi.pure.min.js 的URL不对的情况<br>使用最新的URL可以直接将脚本下载到本地</p><a id="more"></a>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>将busuanzi.pure.min.js下载到本地后，显示这么一大坨</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bszCaller,bszTag;!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> c,d,e,a=!<span class="number">1</span>,b=[];ready=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span> a||<span class="string">"interactive"</span>===<span class="built_in">document</span>.readyState||<span class="string">"complete"</span>===<span class="built_in">document</span>.readyState?c.call(<span class="built_in">document</span>):b.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> c.call(<span class="keyword">this</span>)&#125;),<span class="keyword">this</span>&#125;,d=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=<span class="number">0</span>,c=b.length;c&gt;a;a++)b[a].apply(<span class="built_in">document</span>);b=[]&#125;,e=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;a||(a=!<span class="number">0</span>,d.call(<span class="built_in">window</span>),<span class="built_in">document</span>.removeEventListener?<span class="built_in">document</span>.removeEventListener(<span class="string">"DOMContentLoaded"</span>,e,!<span class="number">1</span>):<span class="built_in">document</span>.attachEvent&amp;&amp;(<span class="built_in">document</span>.detachEvent(<span class="string">"onreadystatechange"</span>,e),<span class="built_in">window</span>==<span class="built_in">window</span>.top&amp;&amp;(clearInterval(c),c=<span class="literal">null</span>)))&#125;,<span class="built_in">document</span>.addEventListener?<span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>,e,!<span class="number">1</span>):<span class="built_in">document</span>.attachEvent&amp;&amp;(<span class="built_in">document</span>.attachEvent(<span class="string">"onreadystatechange"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;/loaded|complete/.test(<span class="built_in">document</span>.readyState)&amp;&amp;e()&#125;),<span class="built_in">window</span>==<span class="built_in">window</span>.top&amp;&amp;(c=setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">try</span>&#123;a||<span class="built_in">document</span>.documentElement.doScroll(<span class="string">"left"</span>)&#125;<span class="keyword">catch</span>(b)&#123;<span class="keyword">return</span>&#125;e()&#125;,<span class="number">5</span>)))&#125;(),bszCaller=&#123;<span class="attr">fetch</span>:<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">var</span> c=<span class="string">"BusuanziCallback_"</span>+<span class="built_in">Math</span>.floor(<span class="number">1099511627776</span>*<span class="built_in">Math</span>.random());<span class="built_in">window</span>[c]=<span class="keyword">this</span>.evalCall(b),a=a.replace(<span class="string">"=BusuanziCallback"</span>,<span class="string">"="</span>+c),scriptTag=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>),scriptTag.type=<span class="string">"text/javascript"</span>,scriptTag.defer=!<span class="number">0</span>,scriptTag.src=a,<span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(scriptTag)&#125;,<span class="attr">evalCall</span>:<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">try</span>&#123;a(b); scriptTag.parentElement.removeChild(scriptTag)&#125;<span class="keyword">catch</span>(c)&#123;bszTag.hides()&#125;&#125;)&#125;&#125;&#125;,bszCaller.fetch(<span class="string">"//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;bszTag.texts(a),bszTag.shows()&#125;),bszTag=&#123;<span class="attr">bszs</span>:[<span class="string">"site_pv"</span>,<span class="string">"page_pv"</span>,<span class="string">"site_uv"</span>],<span class="attr">texts</span>:<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;<span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_value_"</span>+b);c&amp;&amp;(c.innerHTML=a[b])&#125;)&#125;,<span class="attr">hides</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">var</span> b=<span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_container_"</span>+a);b&amp;&amp;(b.style.display=<span class="string">"none"</span>)&#125;)&#125;,<span class="attr">shows</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">var</span> b=<span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_container_"</span>+a);b&amp;&amp;(b.style.display=<span class="string">"inline"</span>)&#125;)&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>经过格式化后:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bszCaller, bszTag;</span><br><span class="line">! <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c, d, e, a = !<span class="number">1</span>,</span><br><span class="line">        b = [];</span><br><span class="line">    ready = <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a || <span class="string">"interactive"</span> === <span class="built_in">document</span>.readyState || <span class="string">"complete"</span> === <span class="built_in">document</span>.readyState ? c.call(<span class="built_in">document</span>) : b.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c.call(<span class="keyword">this</span>)</span><br><span class="line">        &#125;), <span class="keyword">this</span></span><br><span class="line">    &#125;, d = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> a = <span class="number">0</span>, c = b.length; c &gt; a; a++) b[a].apply(<span class="built_in">document</span>);</span><br><span class="line">        b = []</span><br><span class="line">    &#125;, e = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        a || (a = !<span class="number">0</span>, d.call(<span class="built_in">window</span>), <span class="built_in">document</span>.removeEventListener ? <span class="built_in">document</span>.removeEventListener(<span class="string">"DOMContentLoaded"</span>, e, !<span class="number">1</span>) : <span class="built_in">document</span>.attachEvent &amp;&amp; (<span class="built_in">document</span>.detachEvent(<span class="string">"onreadystatechange"</span>, e), <span class="built_in">window</span> == <span class="built_in">window</span>.top &amp;&amp; (clearInterval(c), c = <span class="literal">null</span>)))</span><br><span class="line">    &#125;, <span class="built_in">document</span>.addEventListener ? <span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, e, !<span class="number">1</span>) : <span class="built_in">document</span>.attachEvent &amp;&amp; (<span class="built_in">document</span>.attachEvent(<span class="string">"onreadystatechange"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        /loaded|complete/.test(<span class="built_in">document</span>.readyState) &amp;&amp; e()</span><br><span class="line">    &#125;), <span class="built_in">window</span> == <span class="built_in">window</span>.top &amp;&amp; (c = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a || <span class="built_in">document</span>.documentElement.doScroll(<span class="string">"left"</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (b) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        e()</span><br><span class="line">    &#125;, <span class="number">5</span>)))</span><br><span class="line">&#125;(), bszCaller = &#123;</span><br><span class="line">    fetch: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="string">"BusuanziCallback_"</span> + <span class="built_in">Math</span>.floor(<span class="number">1099511627776</span> * <span class="built_in">Math</span>.random());</span><br><span class="line">        <span class="built_in">window</span>[c] = <span class="keyword">this</span>.evalCall(b), a = a.replace(<span class="string">"=BusuanziCallback"</span>, <span class="string">"="</span> + c), scriptTag = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>), scriptTag.type = <span class="string">"text/javascript"</span>, scriptTag.defer = !<span class="number">0</span>, scriptTag.src = a, <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(scriptTag)</span><br><span class="line">    &#125;,</span><br><span class="line">    evalCall: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">            ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    a(b);</span><br><span class="line">                    scriptTag.parentElement.removeChild(scriptTag)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (c) &#123;</span><br><span class="line">                    bszTag.hides()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, bszCaller.fetch(<span class="string">"//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    bszTag.texts(a), bszTag.shows()</span><br><span class="line">&#125;), bszTag = &#123;</span><br><span class="line">    bszs: [<span class="string">"site_pv"</span>, <span class="string">"page_pv"</span>, <span class="string">"site_uv"</span>],</span><br><span class="line">    texts: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_value_"</span> + b);</span><br><span class="line">            c &amp;&amp; (c.innerHTML = a[b])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    hides: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_container_"</span> + a);</span><br><span class="line">            b &amp;&amp; (b.style.display = <span class="string">"none"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    shows: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b = <span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_container_"</span> + a);</span><br><span class="line">            b &amp;&amp; (b.style.display = <span class="string">"inline"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是分析, 其中bszTag起到了控制显示和隐藏功能<br>搜索 <code>bszTag.hides()</code> 调用<br>发现了这个部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    a(b);</span><br><span class="line">    scriptTag.parentElement.removeChild(scriptTag)</span><br><span class="line">&#125; <span class="keyword">catch</span> (c) &#123;</span><br><span class="line">    bszTag.hides()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>bszTag.hides()</code> 前加上console日志, </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    a(b);</span><br><span class="line">    scriptTag.parentElement.removeChild(scriptTag)</span><br><span class="line">&#125; <span class="keyword">catch</span> (c) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(c), bszTag.hides()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把js的资源URL替换到站内，再次重新打开页面时, 打印出了报错 </p>
<p><strong>call removeChild of null</strong></p>
<p>然后在浏览器打开调试终端, 输入 <code>scriptTag</code>, 打印出了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">""</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback_95341178475"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再输入 <code>scriptTag.parentElement</code>, 打印出了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>于是确定问题出现在了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scriptTag.parentElement.removeChild(scriptTag)</span><br></pre></td></tr></table></figure>
<p>这一行</p>
<p>为了不更改这一行代码的功能, 又要避免出现上面的 <code>removeChild of null</code> 问题</p>
<p>于是修改为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    a(b);</span><br><span class="line">    <span class="keyword">if</span>(scriptTag.parentElement) scriptTag.parentElement.removeChild(scriptTag)</span><br><span class="line">&#125; <span class="keyword">catch</span> (c) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(c), bszTag.hides()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后重新build并打开本地服务器, 终于显示除了localhost这个使用最广的站点名的访问数字</p>
<p>然后重新压缩脚本, 扔到站内的lib/js目录， 重新build完推送至Github Pages</p>
<p>刷新页面, 终于一切恢复正常</p>
]]></content>
      <tags>
        <tag>busuanzi</tag>
        <tag>不蒜子</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络库cpp-netlib的简单使用</title>
    <url>/2019/10/29/191029191500/</url>
    <content><![CDATA[<h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接:"></a>友情链接:</h1><p><a href="/2019/10/29/191029190000/">C++网络库cpp-netlib的安装</a></p><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p><strong>cpp-netlib</strong>是基于asio库的http网络库, 包含了HTTP/HTTPS客户端、服务端的接口支持</p><h1 id="cpp-netlib安装位置"><a href="#cpp-netlib安装位置" class="headerlink" title="cpp-netlib安装位置"></a>cpp-netlib安装位置</h1><p>头文件一般安装在 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$&#123;CMAKE_INSTALL_PREFIX&#125;/include/boost/network</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>库文件(.a, .so)一般在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$&#123;CMAKE_INSTALL_PREFIX&#125;/lib/</span><br></pre></td></tr></table></figure>
<p>其中<code>CMAKE_INSTALL_PREFIX</code>是执行安装脚本时候设定的路径， 比如 CMAKE_INSTALL_PREFIX=/usr/local时, 以上的目录则变为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/include/boost/network</span><br><span class="line">/usr/<span class="built_in">local</span>/lib</span><br></pre></td></tr></table></figure>

<h1 id="写服务端程序时"><a href="#写服务端程序时" class="headerlink" title="写服务端程序时"></a>写服务端程序时</h1><h2 id="需要包含的头文件"><a href="#需要包含的头文件" class="headerlink" title="需要包含的头文件"></a>需要包含的头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;network/uri.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/network/protocol/http/server.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="需要引入的库"><a href="#需要引入的库" class="headerlink" title="需要引入的库"></a>需要引入的库</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(app</span><br><span class="line">    boost_system</span><br><span class="line">    network-uri</span><br><span class="line">    cppnetlib-server-parsers</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>其中<code>cppnetlib-server-parsers</code>时服务端解析请求时所需要的库<br><code>network-uri</code>是我们自己在解析请求参数的path、query、host、port、protocol等参数需要用到的库<br><code>boost_system</code>是cppnetlib-server-parsers以及我们在使用cpp-netlib是调用的一些借口内部依赖的库</p>
<h1 id="示例代码-C-11-cpp-netlib-版本-0-12-0"><a href="#示例代码-C-11-cpp-netlib-版本-0-12-0" class="headerlink" title="示例代码(C++11, cpp-netlib 版本: 0.12.0)"></a>示例代码(C++11, cpp-netlib 版本: 0.12.0)</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;network/uri.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sspdlog/sspdlog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/network/protocol/http/server.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> http = boost::network::http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Controller</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SimpleHTTPServer = http::server&lt;Controller&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Controller</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(SimpleHTTPServer::request <span class="keyword">const</span> &amp;request,</span></span></span><br><span class="line"><span class="function"><span class="params">                     SimpleHTTPServer::connection_ptr response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( request.method == <span class="string">"GET"</span>) &#123;</span><br><span class="line">            response-&gt;set_status(SimpleHTTPServer::connection::ok);</span><br><span class="line">            response-&gt;set_headers(<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">                                      &#123;<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>&#125;</span><br><span class="line">                                  &#125;);</span><br><span class="line">            response-&gt;write(json&#123;</span><br><span class="line">                                &#123;<span class="string">"say"</span>, <span class="string">"Who are you?"</span>&#125;</span><br><span class="line">                            &#125;.dump(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[REQ] Source: "</span> &lt;&lt; request.source; <span class="comment">/// client info: &lt;ip&gt;:&lt;port&gt;</span></span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[REQ] Destination: "</span> &lt;&lt; request.destination; <span class="comment">/// path: /index?name=sb</span></span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[REQ] Body: "</span> &lt;&lt; request.body; <span class="comment">/// Body data: &#123;"data": [0, 0]&#125;</span></span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[REQ] Version: "</span> <span class="comment">/// HTTP version</span></span><br><span class="line">                      &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(request.http_version_major)</span><br><span class="line">                      &lt;&lt; <span class="string">'.'</span></span><br><span class="line">                      &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(request.http_version_minor);</span><br><span class="line"></span><br><span class="line">        network::<span class="function">uri <span class="title">uri</span><span class="params">(<span class="string">"http://localhost:9090"</span> + request.destination)</span></span>;</span><br><span class="line"></span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[URI] Host: "</span> &lt;&lt; uri.host();</span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[URI] Port: "</span> &lt;&lt; uri.port&lt;<span class="keyword">unsigned</span>&gt;();</span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[URI] Query: "</span> &lt;&lt; uri.query();</span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[URI] Route: "</span> &lt;&lt; uri.path();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(SimpleHTTPServer::string_type <span class="keyword">const</span> &amp;info)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR: "</span> &lt;&lt; info &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Controller control&#123;&#125;;</span><br><span class="line">    SimpleHTTPServer::<span class="function">options <span class="title">options</span><span class="params">(control)</span></span>;</span><br><span class="line">    <span class="function">SimpleHTTPServer <span class="title">server</span><span class="params">(options.address(<span class="string">"0.0.0.0"</span>).port(<span class="string">"9090"</span>))</span></span>;</span><br><span class="line">    server.run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所用到的工具库:<br><a href="https://github.com/nlohmann/json.git" target="_blank" rel="noopener">nlohmann/json</a><br><a href="/downloads/sspdlog_0.1.1-1_amd64.deb">sspdlog</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>cpp-netlib</tag>
      </tags>
  </entry>
  <entry>
    <title>C++网络库cpp-netlib的安装</title>
    <url>/2019/10/29/191029190000/</url>
    <content><![CDATA[<h1 id="开发环境-Ubuntu-16-04"><a href="#开发环境-Ubuntu-16-04" class="headerlink" title="开发环境: Ubuntu 16.04"></a>开发环境: Ubuntu 16.04</h1><ol>
<li>安装boost</li>
</ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ sudo aptitude install libboost-all-dev</span><br></pre></td></tr></table></figure><ol start="2">
<li>安装openssl</li>
</ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ sudo aptitude install openssl libssl-dev</span><br></pre></td></tr></table></figure><h1 id="下载cpp-netlib"><a href="#下载cpp-netlib" class="headerlink" title="下载cpp-netlib"></a>下载cpp-netlib</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ mkdir -p workspace</span><br><span class="line">~$ <span class="built_in">cd</span> workspace</span><br><span class="line">~$ git <span class="built_in">clone</span> https://github.com/cpp-netlib/cpp-netlib</span><br></pre></td></tr></table></figure><a id="more"></a>







<h1 id="更新cpp-netlib的三方依赖"><a href="#更新cpp-netlib的三方依赖" class="headerlink" title="更新cpp-netlib的三方依赖"></a>更新cpp-netlib的三方依赖</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ <span class="built_in">cd</span> cpp-netlib</span><br><span class="line">~$ git submodule init</span><br><span class="line">~$ git submodule update</span><br></pre></td></tr></table></figure>

<h1 id="修改-build-sh脚本适合自己的编译-如启动共享库，-启动HTTPS等选项"><a href="#修改-build-sh脚本适合自己的编译-如启动共享库，-启动HTTPS等选项" class="headerlink" title="修改 build.sh脚本适合自己的编译(如启动共享库， 启动HTTPS等选项)"></a>修改 build.sh脚本适合自己的编译(如启动共享库， 启动HTTPS等选项)</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">cmake -Bbuild -H. \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">  -DBUILD_SHARED_LIBS=ON \</span><br><span class="line">  -DCPP-NETLIB_ENABLE_HTTPS=ON \</span><br><span class="line">  -DCPP-NETLIB_BUILD_EXAMPLES=OFF \</span><br><span class="line">  -DCPP-NETLIB_BUILD_DOCS=ON \</span><br><span class="line">  -DUri_BUILD_TESTS=OFF \</span><br><span class="line">  -DUri_BUILD_DOCS=ON \</span><br><span class="line">  -DUri_DISABLE_LIBCXX=ON \</span><br><span class="line">  -DCMAKE_CXX_FLAGS=<span class="string">"-std=c++11 <span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span>"</span> \</span><br><span class="line">  -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure>

<h1 id="执行build-sh脚本编译"><a href="#执行build-sh脚本编译" class="headerlink" title="执行build.sh脚本编译"></a>执行build.sh脚本编译</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ ./build.sh</span><br></pre></td></tr></table></figure>

<h1 id="编译没有报错的话-执行安装-可能要加上-sudo"><a href="#编译没有报错的话-执行安装-可能要加上-sudo" class="headerlink" title="编译没有报错的话, 执行安装(可能要加上 sudo)"></a>编译没有报错的话, 执行安装(可能要加上 <code>sudo</code>)</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ $  cmake --build build --target install</span><br></pre></td></tr></table></figure>

<h1 id="至此cpp-netlib安装完成"><a href="#至此cpp-netlib安装完成" class="headerlink" title="至此cpp-netlib安装完成"></a>至此cpp-netlib安装完成</h1>]]></content>
      <tags>
        <tag>cpp-netlib</tag>
        <tag>asio</tag>
        <tag>C++ Network</tag>
      </tags>
  </entry>
  <entry>
    <title>本站引导</title>
    <url>/2019/10/26/index/</url>
    <content><![CDATA[<h2 id="我的博文"><a href="#我的博文" class="headerlink" title="我的博文"></a>我的博文</h2><h2 id="我的开源项目"><a href="#我的开源项目" class="headerlink" title="我的开源项目"></a>我的开源项目</h2><p>C:<br><a href="https://github.com/oyoungs/libwebsockets" target="_blank" rel="noopener">libwebsockets(官方repo稍作改动)</a><br><a href="https://github.com/oyoungs/zbuffer" target="_blank" rel="noopener">zBuffer</a><br>C++:<br><a href="https://github.com/oyoungs/dispatch" target="_blank" rel="noopener">个人通用开发工具库</a><br><a href="https://github.com/oyoungs/SoundManager" target="_blank" rel="noopener">基于libasound库音频播放</a><br><a href="https://github.com/oyoungs/topice" target="_blank" rel="noopener">基于rostopic的服务调用封装</a><br>Qt:<br><a href="https://github.com/oyoungs/QAsyncTask" target="_blank" rel="noopener">Qt异步事件库</a></p>]]></content>
  </entry>
  <entry>
    <title>使用SDL2_mixer库播放MP3音乐</title>
    <url>/2019/10/23/191023102758/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/102696213" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/102696213</a></p><h2 id="运行环境：Ubuntu-16-04"><a href="#运行环境：Ubuntu-16-04" class="headerlink" title="运行环境：Ubuntu:16.04"></a>运行环境：Ubuntu:16.04</h2><h3 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h3><p>安装libsdl2-mixer-dev </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ sudo apt install libsdl2-mixer-dev</span><br></pre></td></tr></table></figure><h3 id="需要包含的头文件"><a href="#需要包含的头文件" class="headerlink" title="需要包含的头文件"></a>需要包含的头文件</h3><a id="more"></a>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL_mixer.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="需要链接的库文件"><a href="#需要链接的库文件" class="headerlink" title="需要链接的库文件"></a>需要链接的库文件</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">"-pthread $&#123;CMAKE_CXX_FLAGS&#125;"</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app</span><br><span class="line">    SDL2</span><br><span class="line">    SDL2_mixer</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>-&gt; <strong>Mix_Init</strong><br>-&gt; <strong>Mix_OpenAudio</strong><br>-&gt; <strong>Mix_LoadMUS / Mix_LoadWAV</strong><br>-&gt; <strong>Mix_PlayMusic / Mix_FadeInMusic / Mix_PlayChanel / Mix_FadeInChannel</strong><br>-&gt; <strong>Others User Operations</strong><br>-&gt; <strong>Mix_HaltMusic / Mix_FadeOutMusic / Mix_HaltChannel / Mix_FaleOutChannel</strong><br>-&gt; <strong>Mix_CloseAudio</strong><br>-&gt; <strong>Mix_Quit</strong></p>
<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><ul>
<li><strong>Mix_HookMusic</strong>: 用于设置音乐播放过程中的回调</li>
<li><strong>Mix_HookMusicFinished</strong>:  用于设置音乐播放结束时的回调</li>
</ul>
<h2 id="示例代码-C-11"><a href="#示例代码-C-11" class="headerlink" title="示例代码(C++11)"></a>示例代码(C++11)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL_mixer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;oyoung/defer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sspdlog/sspdlog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; on_signal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_TERM_handle</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(on_signal) on_signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    USE_DEFER;</span><br><span class="line"></span><br><span class="line">    on_signal = [&amp;] &#123;</span><br><span class="line">        __defer__.~Defer();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::signal(SIGTERM, signal_TERM_handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> n = Mix_Init(MIX_INIT_OGG | MIX_INIT_MP3 | MIX_INIT_FLAC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"[Mix_Init] Failed initialization: "</span> &lt;&lt; Mix_GetError();</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SSPD_LOG_INFO &lt;&lt; <span class="string">"[Mix_Init] Mix initialize successfully"</span>;</span><br><span class="line"></span><br><span class="line">    defer [=] &#123;</span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[Mix_Quit] Mix will quit"</span>;</span><br><span class="line">        Mix_Quit();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    n = Mix_OpenAudio(MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, MIX_DEFAULT_CHANNELS, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"[Mix_OpenAudio] Failed open audio: "</span> &lt;&lt; Mix_GetError();</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SSPD_LOG_INFO &lt;&lt; <span class="string">"[Mix_OpenAudio] Open Audio successfully"</span>;</span><br><span class="line"></span><br><span class="line">    defer [=] &#123;</span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[Mix_CloseAudio] Mix will close audio"</span>;</span><br><span class="line">        Mix_CloseAudio();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> music = Mix_LoadMUS(<span class="string">"/home/oyoung/Music/8.mp3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(music == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"[Mix_LoadMUS] Failed load music: "</span> &lt;&lt; Mix_GetError();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SSPD_LOG_INFO &lt;&lt; <span class="string">"[Mix_LoadMUS] Load music successfully"</span>;</span><br><span class="line"></span><br><span class="line">    defer [=] &#123;</span><br><span class="line">       SSPD_LOG_INFO &lt;&lt; <span class="string">"[Mix_FreeMusic] Music will be free"</span>;</span><br><span class="line">       Mix_FreeMusic(music);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    n = Mix_FadeInMusic(music, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    Mix_HookMusicFinished([] &#123;</span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[Main] Music play finished"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"[Mix_FadeInMusic] Failed fade in music: "</span> &lt;&lt; Mix_GetError();</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SSPD_LOG_INFO &lt;&lt; <span class="string">"[Mix_FadeInMusic] Music start playing"</span>;</span><br><span class="line"></span><br><span class="line">    defer [=] &#123;</span><br><span class="line">        SSPD_LOG_INFO &lt;&lt; <span class="string">"[Mix_FadeOutMusic] Mix will fade out music"</span>;</span><br><span class="line">        Mix_FadeOutMusic(<span class="number">1000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Mix_PlayingMusic()) &#123;</span><br><span class="line">        SDL_Delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2019-10-23 10:30:55.443]-[info]- [Mix_Init] Mix initialize successfully (main.cc <span class="comment">#32 main)</span></span><br><span class="line">[2019-10-23 10:30:55.458]-[info]- [Mix_OpenAudio] Open Audio successfully (main.cc <span class="comment">#46 main)</span></span><br><span class="line">[2019-10-23 10:30:55.458]-[info]- [Mix_LoadMUS] Load music successfully (main.cc <span class="comment">#60 main)</span></span><br><span class="line">[2019-10-23 10:30:55.458]-[info]- [Mix_FadeInMusic] Music start playing (main.cc <span class="comment">#79 main)</span></span><br><span class="line">[2019-10-23 10:31:00.712]-[info]- [Mix_FadeOutMusic] Mix will fade out music (main.cc <span class="comment">#82 operator())</span></span><br><span class="line">[2019-10-23 10:31:00.713]-[info]- [Mix_FreeMusic] Music will be free (main.cc <span class="comment">#63 operator())</span></span><br><span class="line">[2019-10-23 10:31:01.724]-[info]- [Main] Music play finished (main.cc <span class="comment">#70 operator())</span></span><br><span class="line">[2019-10-23 10:31:01.739]-[info]- [Mix_CloseAudio] Mix will close audio (main.cc <span class="comment">#49 operator())</span></span><br><span class="line">[2019-10-23 10:31:01.755]-[info]- [Mix_Quit] Mix will quit (main.cc <span class="comment">#35 operator())</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>SDL</tag>
        <tag>SDL_mixer</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 按文件列表拷贝文件到指定目录并保持原有的目录结构</title>
    <url>/2019/10/18/191018095419/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/102619309" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/102619309</a></p><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>当需要拷贝多个文件并且需要保留源文件的目录树结构时， 如果源目录的文件比较纯净，没有其他相关的文件或目录时， 我们只需要执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ <span class="comment">#cp -r &lt;源目录&gt; &lt;新目录&gt;</span></span><br><span class="line">~$ cp -r workspace/project workspace/Cpp</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>但是, 如果我们需要拷贝的文件所在的目录里包含了其他项目或程序的文件或目录, 那我们就不能这么干</p>
<p>比如, </p>
<ul>
<li>在  /etc或者/usr/local/bin下面有很多我们自己项目的相关配置文件和程序文件, 并且我们知道这些文件路径</li>
<li>包含指定字符串的文件名, 比如 *.log</li>
<li>我们自己制作或者我们比较感兴趣的其他厂商的 *.deb程序包(Ubuntu使用软件包)</li>
</ul>
<h2 id="针对自己的项目配置文件"><a href="#针对自己的项目配置文件" class="headerlink" title="针对自己的项目配置文件"></a>针对自己的项目配置文件</h2><p>我们可以新建一个文本文档, 里面把我们所关心的文件列出来</p>
<p>list.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/app/app.cnf</span><br><span class="line">/etc/app/conf.d/a.cnf</span><br><span class="line">/etc/app/conf.d/b.cnf</span><br><span class="line">/etc/app/conf.d/c.cnf</span><br><span class="line">/etc/app/conf.d/d.cnf</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过使用 cat list.txt 获取到我们的文件路径列表</p>
<p>此时我们只需要使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ cp --parent $(cat list.txt) .</span><br></pre></td></tr></table></figure>
<p>就可以将列表里面的所有文件按照原有的目录树结构拷贝到当前目录(或者使用其他目录)</p>
<h2 id="针对包含指定字符串的文件名我们可以用-find-命令获取到文件列表"><a href="#针对包含指定字符串的文件名我们可以用-find-命令获取到文件列表" class="headerlink" title="针对包含指定字符串的文件名我们可以用 find 命令获取到文件列表"></a>针对包含指定字符串的文件名我们可以用 find 命令获取到文件列表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ find /opt/ros/ -name *.a</span><br><span class="line">/opt/ros/kinetic/lib/liboctomath.a</span><br><span class="line">/opt/ros/kinetic/lib/libcsm-static.a</span><br><span class="line">/opt/ros/kinetic/lib/liboptions.a</span><br><span class="line">/opt/ros/kinetic/lib/libegsl.a</span><br><span class="line">/opt/ros/kinetic/lib/liboctomap.a</span><br><span class="line">~$</span><br></pre></td></tr></table></figure>
<p>然后, 嘿嘿 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ cp --parent $(find /opt/ros -name *.a) .</span><br></pre></td></tr></table></figure>
<p>这不就都按照源目录结构拷贝到当前目录了嘛</p>
<h2 id="针对-deb包的文件列表-我们也有命令可以获取到路径列表"><a href="#针对-deb包的文件列表-我们也有命令可以获取到路径列表" class="headerlink" title="针对.deb包的文件列表, 我们也有命令可以获取到路径列表"></a>针对.deb包的文件列表, 我们也有命令可以获取到路径列表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ dpkg -L mysql-server-5.7 </span><br><span class="line">/etc</span><br><span class="line">/etc/mysql</span><br><span class="line">/etc/mysql/mysql.conf.d</span><br><span class="line">/etc/mysql/mysql.conf.d/mysqld_safe_syslog.cnf</span><br><span class="line">/etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">/etc/mysql/debian-start</span><br><span class="line">/etc/mysql/mysql.cnf</span><br><span class="line">/etc/apparmor.d</span><br><span class="line">/etc/apparmor.d/usr.sbin.mysqld</span><br><span class="line">/etc/logrotate.d</span><br><span class="line">/etc/logrotate.d/mysql-server</span><br><span class="line">/etc/init.d</span><br><span class="line">/etc/init.d/mysql</span><br><span class="line">/etc/logcheck</span><br><span class="line">/etc/logcheck/ignore.d.server</span><br><span class="line">/etc/logcheck/ignore.d.server/mysql-server-5_7</span><br><span class="line">/etc/logcheck/ignore.d.workstation</span><br><span class="line">/etc/logcheck/ignore.d.workstation/mysql-server-5_7</span><br><span class="line">/etc/logcheck/ignore.d.paranoid</span><br><span class="line">/etc/logcheck/ignore.d.paranoid/mysql-server-5_7</span><br><span class="line">/etc/init</span><br><span class="line">/etc/init/mysql.conf</span><br><span class="line">~$</span><br></pre></td></tr></table></figure>

<p>这个时候我们就可以…. -_- 嘿嘿嘿 , 你懂的</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL C/C++客户端api(libmysqlclient-dev) 的使用笔记</title>
    <url>/2019/09/20/190920182322/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/101072215" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/101072215</a></p><h2 id="MySQL-客户端-api-libmysqlclient-dev-的简单使用"><a href="#MySQL-客户端-api-libmysqlclient-dev-的简单使用" class="headerlink" title="MySQL 客户端 api (libmysqlclient-dev)的简单使用"></a>MySQL 客户端 api (libmysqlclient-dev)的简单使用</h2><h2 id="几个常用重要接口"><a href="#几个常用重要接口" class="headerlink" title="几个常用重要接口"></a>几个常用重要接口</h2><ul>
<li>mysql_library_init()</li>
<li>mysql_library_end()</li>
<li>mysql_init()</li>
<li>mysql_connect() / mysql_real_connect()</li>
<li>mysql_query() / mysql_real_query()</li>
<li>mysql_num_fileds()</li>
<li>mysql_num_rows()</li>
<li>mysql_fetch_field() / mysql_fetch_fields()</li>
<li>mysql_fetch_row()</li>
<li>mysql_affected_row()</li>
</ul><a id="more"></a>

<h2 id="几个重要数据类型"><a href="#几个重要数据类型" class="headerlink" title="几个重要数据类型"></a>几个重要数据类型</h2><ul>
<li>MYSQL</li>
<li>MYSQL_RES</li>
<li>MYSQL_ROW</li>
<li>MYSQL_FIELD</li>
</ul>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>cmake</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"-g -lmysqlclient -pthread -lz -lm -lrt -ldl <span class="variable">$CMAKE_CXX_FLAGS</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>g++ build</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o mysql -lmysqlclient -I/usr/include/mysql -L/usr/lib/x86_64-linux-gnu -pthread -lz -lm -lrt -ldl -g main.cc</span><br></pre></td></tr></table></figure>

<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>小提示:</p>
<blockquote>
<p>示例代码中使用到了另外两个三方库<br>一个三方库时sspdlog, 日志库<br>#include &lt;sspdlog/sspdlog.h&gt; 可以替换成 &lt;iostream&gt;,<br>SSPD_LOG_INFO可以替换为std::cout,<br>SSPD_LOG_ERROR可以替换为std::cerr<br>另一个三方库 为 自己的 工具库 <a href="https://github.com/oyoungs/dispatch" target="_blank" rel="noopener">oyoungs/dispatch</a>, 可以到github上下载</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sspdlog/sspdlog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;oyoung/format.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mysql &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">library</span> &#123;</span></span><br><span class="line">        library(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **groups) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mysql_library_init(argc, argv, groups)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"MYSQL Initialize failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~library() &#123;</span><br><span class="line">            mysql_library_end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">row</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        row(MYSQL_ROW row): m_row(row) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ~row() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_row;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_row[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        row(<span class="keyword">const</span> row&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        row(row&amp;&amp; other): m_row(other.m_row) &#123;</span><br><span class="line">            other.m_row = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MYSQL_ROW m_row&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">field</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        field(MYSQL_FIELD *field): m_field(field) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m_field-&gt;name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">catalog</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(m_field-&gt;catalog, m_field-&gt;catalog_length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ~field() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        field(<span class="keyword">const</span> field&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        field(field&amp;&amp; other): m_field(other.m_field) &#123;</span><br><span class="line">            other.m_field = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        MYSQL_FIELD *m_field&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fields</span> :</span> field &#123;</span><br><span class="line"></span><br><span class="line">        fields(MYSQL_FIELD *f) : field(f) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        field <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">            <span class="keyword">return</span> m_field + index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">result</span> &#123;</span></span><br><span class="line">        result() = <span class="keyword">default</span>;</span><br><span class="line">        result(MYSQL_RES *res): m_result(res) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ~result() &#123;</span><br><span class="line">            <span class="keyword">if</span>(m_result) &#123;</span><br><span class="line">                ::mysql_free_result(m_result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        result(<span class="keyword">const</span> result&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        result(result&amp;&amp; other): m_result(other.m_result) &#123;</span><br><span class="line">            other.m_result = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">row <span class="title">fetch_row</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mysql_fetch_row(m_result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">uint64_t</span> rows() <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mysql_num_rows(m_result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">field_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ::mysql_num_fields(m_result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">fields <span class="title">fetch_fields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mysql_fetch_fields(m_result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MYSQL_RES *m_result &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">        client()</span><br><span class="line">            : m_client(mysql_init(<span class="literal">nullptr</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">good</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span> != m_client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">not_good</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span> == m_client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; host, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; password, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; database,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">short</span> port = <span class="number">3306</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mysql_real_connect(m_client, host.c_str(), user.c_str(), password.c_str(), database.c_str(), port, <span class="literal">nullptr</span>, <span class="number">0</span>) != <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sql)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mysql_real_query(m_client, sql.c_str(), sql.length()) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">uint64_t</span> affected_rows() <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mysql_affected_rows(m_client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">uint64_t</span> inserted_id() <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mysql_insert_id(m_client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">result <span class="title">use_result</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result(mysql_use_result(m_client));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ~client() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">error</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mysql_error(m_client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MYSQL *m_client;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> <span class="keyword">try</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mysql::<span class="function">library <span class="title">library</span><span class="params">(argc, argv, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    mysql::client client&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(client.not_good()) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"Create MySQL client failed"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!client.connect(<span class="string">"172.17.0.2"</span>, <span class="string">"blog"</span>, <span class="string">"blog.123"</span>, <span class="string">"blog"</span>)) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"MySQL connect failed: "</span> &lt;&lt; client.error();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!client.query(<span class="string">"INSERT INTO user set name='blog', email='blog@hotmail.com'"</span>)) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"MySQL query INSERT failed: "</span> &lt;&lt; client.error();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SSPD_LOG_INFO &lt;&lt; <span class="string">"MySQL affected rows after insert: "</span> &lt;&lt; client.affected_rows();</span><br><span class="line">    SSPD_LOG_INFO &lt;&lt; <span class="string">"MySQL last inserted ID: "</span> &lt;&lt; client.inserted_id();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!client.query(<span class="string">"SELECT id, name, email FROM user"</span>)) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"MySQL query SELECT failed: "</span> &lt;&lt; client.error();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> result = client.use_result();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> field_count = result.field_count();</span><br><span class="line">    <span class="keyword">auto</span> fields      = result.fetch_fields();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">auto</span> row = result.fetch_row()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; field_count; ++i) &#123;</span><br><span class="line">            SSPD_LOG_INFO &lt;&lt; fields[i].name() &lt;&lt; <span class="string">": "</span> &lt;&lt; row[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!client.query(oyoung::format(<span class="string">"DELETE FROM user WHERE id=%1"</span>).arg(client.inserted_id()).to_string())) &#123;</span><br><span class="line">        SSPD_LOG_ERROR &lt;&lt; <span class="string">"MySQL query DELETE failed: "</span> &lt;&lt; client.error();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SSPD_LOG_INFO &lt;&lt; <span class="string">"MySQL affected rows after delete: "</span> &lt;&lt; client.affected_rows();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">    SSPD_LOG_ERROR &lt;&lt; e.what();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11实现defer</title>
    <url>/2018/05/24/C-11%E5%AE%9E%E7%8E%B0defer/</url>
    <content><![CDATA[<h1 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h1><p>使用过swift开发过iOS应用的广大搬砖工都知道， 在swift语言里， 有一个很好用的关键字 defer<br>这个defer有什么用呢？<br>在某个函数或者代码块中， 如果使用了defer 添加了一段代码， 会发生什么呢？<br>哈哈， 当然是 在代码块结束时， 一定会调用这段代码了。<br>这样有什么好处呢？<br>我们知道， 有些操作需要很多步骤，其中一步出错，就可能需要是整个操作流程结束， 但是结束之前那些已经申请的资源怎么办呢？ 如果不处理肯定会出现资源泄露的啊。这是defer就派上用场了，使用defer 之后， 在后面的代码块中去释放申请占用的资源， 就会保证在代码块结束之前一定会调用这个defer代码块来释放资源， 保证了一定的安全性</p><a id="more"></a>
<h1 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h1><p>那作为一名C++开发者来说，有没有这个便利的工具呢？<br>老实说， 从原生C++角度来说， 是没有这个工具的，有点可惜！ 那我们能不能自己实现呢？</p>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><pre><code>1.  defer 功能是退出代码块时必定会执行代码， C++里面有这种机制吗？ 当然有啊， 局部对象的析构函数， 可行性 +1
2.  defer 后面接的是代码块， C++11以后， 也有了lambda表达式的支持， 可行性再次 +1
3.  defer 后面所接的代码块是不带括号尾部闭包格式， C++ 有什么方式可以以函数对象为参数且不需要括号就能调用的呢？ 哈哈， 有， + - * /  &lt;&lt; &gt;&gt; +=  -= 等等操作符调用时不需要加括号， 可行性再次 +1</code></pre><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><ul>
<li>需要定义一个类</li>
<li>这个类可以通过调用操作符的方式往内部追加一个代码块</li>
<li>该类的对象析构时， 一定会去调用内部保存的代码块</li>
</ul>
<h2 id="动手试试"><a href="#动手试试" class="headerlink" title="动手试试"></a>动手试试</h2><p>不如我们就定义一个类叫Defer好了， 至于用哪个操作符呢？ 凭自己喜好啊， 我这里使用了 += 表示往里头追加， 哈哈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Defer</span> &#123;</span></span><br><span class="line">    Defer&amp; <span class="keyword">operator</span>+=(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; block) &#123;</span><br><span class="line">        m_defers.emplace_back(<span class="built_in">std</span>::move(block));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Defer() &#123;</span><br><span class="line">        <span class="keyword">while</span> (!m_defers.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m_defers.back()) m_defers.back()();</span><br><span class="line">            m_defers.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; m_defers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_DEFER Defer __defer__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> defer __defer__ +=</span></span><br></pre></td></tr></table></figure>

<h2 id="测试看看？"><a href="#测试看看？" class="headerlink" title="测试看看？"></a>测试看看？</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  USE_DEFER;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"new a"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  defer [=] &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete a"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> b = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"new [] b"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  defer [=] &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete [] b"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] b;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是不是预期的呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">new a</span><br><span class="line">new [] b</span><br><span class="line">delete [] b</span><br><span class="line">delete a</span><br></pre></td></tr></table></figure>

<p>哈哈， 还真是！！ 功能实现了</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>这里的 defer 还能用在类中， 确保资源在类对象析构的时候能正确的释放资源</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    File(<span class="built_in">std</span>::<span class="built_in">string</span> path)</span><br><span class="line">        : m_path(<span class="built_in">std</span>::move(path)) &#123;</span><br><span class="line">        defer [=] &#123;</span><br><span class="line">            <span class="keyword">if</span>(m_descriptor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"close file "</span> &lt;&lt; m_path &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                ::close(m_descriptor);</span><br><span class="line">                m_descriptor = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"open file "</span> &lt;&lt; m_path &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        m_descriptor = ::open(m_path.c_str(), O_RDONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    USE_DEFER;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_path;</span><br><span class="line">    <span class="keyword">int</span> m_descriptor&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">File <span class="title">file</span><span class="params">(<span class="string">"./test.log"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    file.open();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预期结果<br>① 当文件不存在时:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open file ./test.log</span><br></pre></td></tr></table></figure>
<p>② 当文件存在时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open file ./test.log</span><br><span class="line">close file ./test.log</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++11</tag>
        <tag>defer</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础学iOS系列之swift语法基础</title>
    <url>/2017/11/15/171115190448/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/78543979" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/78543979</a></p><h1 id="1-变量与数据类型"><a href="#1-变量与数据类型" class="headerlink" title="1.  变量与数据类型"></a>1.  变量与数据类型</h1><h2 id="a-数据类型"><a href="#a-数据类型" class="headerlink" title="a)   数据类型"></a>a)   数据类型</h2><h3 id="i-基本数据类型"><a href="#i-基本数据类型" class="headerlink" title="i.     基本数据类型"></a>i.     基本数据类型</h3><p>整数类型 </p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Int</span>, <span class="type">UInt</span>, <span class="type">Int8</span>, <span class="type">UInt8</span>, <span class="type">Int16</span>,<span class="type">UInt16</span>, <span class="type">Int32</span>, <span class="type">UInt32</span>, <span class="type">Int64</span>, <span class="type">UInt64</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>实数类型 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Double</span>, <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure>
<p>字符串 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>集合类型 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>, <span class="type">Dictionary</span></span><br></pre></td></tr></table></figure>
<h3 id="ii-类型之间的转换-调用目标类型的构造函数"><a href="#ii-类型之间的转换-调用目标类型的构造函数" class="headerlink" title="ii.     类型之间的转换(调用目标类型的构造函数)"></a>ii.     类型之间的转换(调用目标类型的构造函数)</h3><p>整数类型 –&gt; 实数类型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Double</span> = <span class="type">Double</span>(n)</span><br></pre></td></tr></table></figure>
<p>数字类型 -&gt; 字符串类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> stringValue = <span class="type">String</span>(number)</span><br></pre></td></tr></table></figure>
<h2 id="b-变量的声明"><a href="#b-变量的声明" class="headerlink" title="b)   变量的声明"></a>b)   变量的声明</h2><h3 id="i-基本声明方法"><a href="#i-基本声明方法" class="headerlink" title="i.     基本声明方法"></a>i.     基本声明方法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>/<span class="keyword">var</span> name[: <span class="type">Type</span>][ = <span class="type">Initialization</span>]</span><br></pre></td></tr></table></figure>
<p>中括号内表示可省略, 但第一个中括号与第二个中括号内的内容只能省略一处， 除了类成员属性有默认值的情况不需要省略，其他均建议采用省略形式， 如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> string: <span class="type">String?</span></span><br></pre></td></tr></table></figure>
<h3 id="ii-使用let声明"><a href="#ii-使用let声明" class="headerlink" title="ii.     使用let声明"></a>ii.     使用let声明</h3><p>表示常量，声明之后只允许有一次赋值， 如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line">x = <span class="number">100</span> <span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>
<h3 id="iii-使用var声明"><a href="#iii-使用var声明" class="headerlink" title="iii.     使用var声明"></a>iii.     使用var声明</h3><p>表示变量， 一次声明，可以多次修改其值， 但效率没有let高</p>
<h3 id="iv-let-与var的区别与使用规则"><a href="#iv-let-与var的区别与使用规则" class="headerlink" title="iv.     let 与var的区别与使用规则"></a>iv.     let 与var的区别与使用规则</h3><p>区别在于前者声明的变量为值不可变，后者值可变，前者效率更高，使用原则：<br>方法体中，<strong>优先使用let, 当需要修改变量值的时候， 根据编译器提示和修改建议进行修改即可</strong></p>
<h3 id="v-语法糖"><a href="#v-语法糖" class="headerlink" title="v.     语法糖"></a>v.     语法糖</h3><p>适用于Array，Dictionary和Optional， 但写法更简洁，<br>对于数组， 应该写成</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array: [<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>
<p>而不建议写成</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array: <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;</span><br></pre></td></tr></table></figure>
<p>对于字典， 应该写成</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dict: [<span class="type">String</span>: <span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<p>而不应该写成</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dict: <span class="type">Dictionary</span>&lt;<span class="type">String</span>,<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure>
<p>对于Optional，从名字上看叫可选值， 也就是可空值， 表示该类型的变量的值可以是nil(或者.None)， 建议使用简洁形式声明可选类型变量, 如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String?</span></span><br></pre></td></tr></table></figure>
<p>而不要使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">Optional</span>(<span class="type">String</span>)</span><br></pre></td></tr></table></figure>
<h3 id="c-区间"><a href="#c-区间" class="headerlink" title="c)  区间"></a>c)  区间</h3><p>区间分为半开区间和闭区间，区间值必须为整数， 半开区间用..&lt;表示， 如0到99， 则可以表示为</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ..&lt; <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>闭区间用…表示， 如0到99表示为 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> … <span class="number">99</span></span><br></pre></td></tr></table></figure>

<p>早期版本中, <code>..&lt;</code> 和<code>...</code>后面的数字或者变量需要紧跟，不得有空格, 比较新的版本中去掉了这个限制</p>
<h1 id="2-控制语句"><a href="#2-控制语句" class="headerlink" title="2.  控制语句"></a>2.  控制语句</h1><h2 id="a-条件语句"><a href="#a-条件语句" class="headerlink" title="a) 条件语句"></a>a) 条件语句</h2><h3 id="i-if-else语句"><a href="#i-if-else语句" class="headerlink" title="i. if else语句"></a>i. if else语句</h3><p>最基本的条件判断，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件 &#123;</span><br><span class="line">    <span class="comment">//条件为真的时候的操作</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//条件为假时的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>else 后仍可接ifelse完成语句，如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">//条件1为真的时候的操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 条件<span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">//条件2为真的时候的操作</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//条件为假时的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ii-guard-else-语句"><a href="#ii-guard-else-语句" class="headerlink" title="ii. guard else 语句"></a>ii. guard else 语句</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> 条件 <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>/<span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示确保条件成立的情况下继续往下执行，否则执行完else中的内容后退出，break/return要求必须写一个，因此guard语句一般在方法体中或者循环中使用，具体看使用情况，guardelse语句一般用来避免嵌套ifelse 语句造成的代码结构混乱</p>
<h3 id="iii-if-let-语句"><a href="#iii-if-let-语句" class="headerlink" title="iii. if let 语句"></a>iii. if let 语句</h3><p>表示可选值的绑定，如果可选值非空，可以绑定成功，则执行后面{ }中的语句，否则跳过{ }<br>形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> some = someOptioal &#123;</span><br><span class="line">    <span class="comment">//如果someOptional的值不是nil，则执行此处代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if let语句也可以和if else语句一样，可以有else分支，如果有多个可选值需要绑定，只需要在{ }前面增加let 语句即可，然后与前面的语句用英文逗号隔开<br><strong>if let 语句可以用来避免使用！进行强制拆包导致的nil异常</strong></p>
<h3 id="iv-guard-let-…-else语句"><a href="#iv-guard-let-…-else语句" class="headerlink" title="iv. guard let … else语句"></a>iv. guard let … else语句</h3><p>类似于if let，同样用于可选值绑定，绑定失败则执行else 后面的{ }里面的语句并退出</p>
<h2 id="b-选择语句"><a href="#b-选择语句" class="headerlink" title="b)   选择语句"></a>b)   选择语句</h2><p>switch case语句<br>使用形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> some &#123;</span><br><span class="line"><span class="keyword">case</span> value1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> value2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用要求， 如果some为枚举类型的变量，则不建议使用default分支, 应该将所有枚举值case 出来， 如果some为非枚举类型变量，则要求必须有default分支，且每一个case分支下如果语句非空， 则不需要使用break，否则需要在该分支使用break，case 分支的值除了可以是单个的值之外，也可以是区间</p>
<h2 id="c-循环语句"><a href="#c-循环语句" class="headerlink" title="c) 循环语句"></a>c) 循环语句</h2><h3 id="i-传统的for循环，-不建议使用"><a href="#i-传统的for循环，-不建议使用" class="headerlink" title="i.  传统的for循环， 不建议使用"></a>i.  传统的for循环， 不建议使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">init</span>; condition; change&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ii-用于对集合类型的遍历-建议使用"><a href="#ii-用于对集合类型的遍历-建议使用" class="headerlink" title="ii. 用于对集合类型的遍历, 建议使用"></a>ii. 用于对集合类型的遍历, 建议使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> some <span class="keyword">in</span> collection &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iii-while循环"><a href="#iii-while循环" class="headerlink" title="iii.  while循环"></a>iii.  while循环</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span> condition &#123;</span><br><span class="line"><span class="comment">///循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iv-repeat-while循环"><a href="#iv-repeat-while循环" class="headerlink" title="iv.  repeat while循环"></a>iv.  repeat while循环</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure>
<p>与while循环功能相同， 但是区别在于while循环先判断在执行， repeat while语句先执行后判断</p>
<h2 id="d-循环中的跳转"><a href="#d-循环中的跳转" class="headerlink" title="d)   循环中的跳转"></a>d)   循环中的跳转</h2><p>跳过当前循环，使用continue, 终止当前循环，使用break， break可以终止多层循环，配合标签使用， 如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lp:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> i* i == j * j * j &#123;</span><br><span class="line">           <span class="keyword">break</span> lp</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-自定义类型"><a href="#3-自定义类型" class="headerlink" title="3.  自定义类型"></a>3.  自定义类型</h1><h2 id="a-typealias使用"><a href="#a-typealias使用" class="headerlink" title="a)   typealias使用"></a>a)   typealias使用</h2><p>给已有类型取别名， 如 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Point</span> = (<span class="type">Double</span>, <span class="type">Double</span>)</span><br></pre></td></tr></table></figure>
<p>表示将(Double， Double)类型的元组取别名为Point</p>
<h2 id="b-enum"><a href="#b-enum" class="headerlink" title="b)   enum"></a>b)   enum</h2><p>定义枚举类型， 枚举值以case 为前缀列举, 如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">School</span></span>&#123;</span><br><span class="line"><span class="keyword">case</span> primary</span><br><span class="line"><span class="keyword">case</span> middleSchool</span><br><span class="line"><span class="keyword">case</span> university</span><br><span class="line"><span class="keyword">case</span> college</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与其他语言不同， 枚举值中也可以有包括构造方法在内的方法存在，也可以以其他如Int 类型为父类进行继承<br>除此之外 Swift中的枚举类型还可以有附加值, 比如:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Property</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> name(<span class="type">String</span>)</span><br><span class="line">	<span class="keyword">case</span> age(<span class="type">Int</span>)</span><br><span class="line">	<span class="keyword">case</span> gender(<span class="type">Bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在使用switch语句的时候，除了可以根据类型选择分支， 还能获取到改枚举类型的附加值, 比如:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> prop = <span class="type">Property</span>.name(<span class="string">"Who"</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">switch</span> prop &#123;</span><br><span class="line">	<span class="keyword">case</span> .name(<span class="keyword">let</span> name): &#123;</span><br><span class="line">		<span class="built_in">print</span>(name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> .age(<span class="keyword">let</span> age): &#123;</span><br><span class="line">		<span class="built_in">print</span>(age)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> .gender(<span class="keyword">let</span> gender): &#123;</span><br><span class="line">		<span class="built_in">print</span>(gender)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-struct"><a href="#c-struct" class="headerlink" title="c)   struct"></a>c)   struct</h2><p>声明一个类，但是该类属于值类型，每一个该类型的变量之间互不相关，修改任何一个该类型变量不会影响到其他同类型变量的值</p>
<h2 id="d-class"><a href="#d-class" class="headerlink" title="d)   class"></a>d)   class</h2><p>与struct相同，也是声明一个类， 但区别在于， 声明的类为引用类型，如果将该类型的一个变量赋值给另一个同类型变量，则这两个变量指向的是同一个实体，如果有其中一个变量修改了实体的某个值， 另一个变量的实体的值会跟着修改</p>
<h2 id="e-protocol"><a href="#e-protocol" class="headerlink" title="e)   protocol"></a>e)   protocol</h2><p>表示协议， 用来声明接口， 声明后不可直接使用，只能使用class或者struct声明的类实现该协议</p>
]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos2d-x的运行框架思维导图</title>
    <url>/2017/11/09/171109110650/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/78487313" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/78487313</a></p><p>花了点时间用思维导图将cocos2d-x游戏开发过程中cocos2d-x框架的大致的整个运行流程，以下内容为思维导图截图<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTA5MTEwNDE1NDEw?x-oss-process=image/format,png" alt="思维导图"></p>]]></content>
      <tags>
        <tag>cocos2dx</tag>
      </tags>
  </entry>
  <entry>
    <title>科大讯飞语音SDK使用流程</title>
    <url>/2017/07/31/170731114031/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/76423309" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/76423309</a></p><h2 id="语音识别部分"><a href="#语音识别部分" class="headerlink" title="语音识别部分"></a>语音识别部分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MSPLogin <span class="comment">// 登录讯飞服务器 </span></span><br><span class="line">MSPUploadData <span class="comment">//(可选): 上传语法文件</span></span><br><span class="line">QISRSessionBegin <span class="comment">// 创建语音识别会话</span></span><br><span class="line">QISRAudioWrite <span class="comment">// 上传语音数据</span></span><br><span class="line">QISRGetResult <span class="comment">// 获取识别的文本结果</span></span><br><span class="line">QISRSessionEnd <span class="comment">// 结束会话</span></span><br><span class="line">MSPLogout <span class="comment">// 注销登录</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<h2 id="语音合成部分"><a href="#语音合成部分" class="headerlink" title="语音合成部分"></a>语音合成部分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MSPLogin <span class="comment">// 登录讯飞服务器</span></span><br><span class="line">QTTSSessionBegin <span class="comment">// 创建语音合成会话</span></span><br><span class="line">QTTSTextPut <span class="comment">// 上传需要合成语音的文本</span></span><br><span class="line">QTTSAudioGet <span class="comment">// 获取服务器合成的语音数据，数据格式为PCM或wav</span></span><br><span class="line">QTTSSessonEnd <span class="comment">// 结束语音合成会话</span></span><br><span class="line">MSPLogout <span class="comment">// 注销登录</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>科大讯飞</tag>
        <tag>语音识别</tag>
        <tag>语音合成</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转树莓派之ROS下更新boost库</title>
    <url>/2017/07/31/170731112804/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/76422821" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/76422821</a></p><h2 id="1-首先你需要下载boost的源码-下载完成解压"><a href="#1-首先你需要下载boost的源码-下载完成解压" class="headerlink" title="1. 首先你需要下载boost的源码,下载完成解压"></a>1. 首先你需要下载boost的源码,下载完成解压</h2><h2 id="2-打开终端，进入到解压目录，-执行以下命令对boost进行编译"><a href="#2-打开终端，进入到解压目录，-执行以下命令对boost进行编译" class="headerlink" title="2. 打开终端，进入到解压目录， 执行以下命令对boost进行编译"></a>2. 打开终端，进入到解压目录， 执行以下命令对boost进行编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ $ ./bootstrap.sh —prefix=/usr</span><br><span class="line">~ $ ./b2 -j2</span><br></pre></td></tr></table></figure><a id="more"></a>

<h2 id="3-安装boost库"><a href="#3-安装boost库" class="headerlink" title="3. 安装boost库"></a>3. 安装boost库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ $ sudo ./bjam install</span><br></pre></td></tr></table></figure>
<h2 id="4-由于是在已安装ros环境下更新boost库，所以更新之后需要重新编译ros，重新安装ros之前需要删除旧的"><a href="#4-由于是在已安装ros环境下更新boost库，所以更新之后需要重新编译ros，重新安装ros之前需要删除旧的" class="headerlink" title="4. 由于是在已安装ros环境下更新boost库，所以更新之后需要重新编译ros，重新安装ros之前需要删除旧的:"></a>4. 由于是在已安装ros环境下更新boost库，所以更新之后需要重新编译ros，重新安装ros之前需要删除旧的:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ $ sudo rm -rf /opt/ros/*</span><br></pre></td></tr></table></figure>
<h2 id="5-最后一步就是进入到ros-ws安装源码目录重新安装ros了"><a href="#5-最后一步就是进入到ros-ws安装源码目录重新安装ros了" class="headerlink" title="5. 最后一步就是进入到ros_ws安装源码目录重新安装ros了"></a>5. 最后一步就是进入到ros_ws安装源码目录重新安装ros了</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ $ ./src/catkin/bin/catkin_make_isolated --install </span><br><span class="line">-DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/opt/ros/kinetic -j2</span><br></pre></td></tr></table></figure>
<p><strong>安装完成之后可以执行ros的一些命令检查是否安装成功</strong></p>
]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>ROS</tag>
        <tag>Boost</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转树莓派之在树莓派Jessie系统中安装ROS</title>
    <url>/2017/07/31/170731111833/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/76422994" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/76422994</a></p><h3 id="0-进入ROSWIKI官网"><a href="#0-进入ROSWIKI官网" class="headerlink" title="0. 进入ROSWIKI官网"></a>0. 进入ROSWIKI官网</h3><p>链接: <a href="http://wiki.ros.org/kinetic/Installation/Debian" target="_blank" rel="noopener">http://wiki.ros.org/kinetic/Installation/Debian</a>,<br>这里有英文文档，以下部分为个人理解下的中文步骤</p><a id="more"></a>

<h3 id="1-建立你的sources-list文件，使你的树莓派支持从ROS官方-站点下载软件，执行以下命令："><a href="#1-建立你的sources-list文件，使你的树莓派支持从ROS官方-站点下载软件，执行以下命令：" class="headerlink" title="1. 建立你的sources.list文件，使你的树莓派支持从ROS官方``站点下载软件，执行以下命令："></a>1. 建立你的sources.list文件，使你的树莓派支持从ROS官方``站点下载软件，执行以下命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi: ~ $ sudo <span class="built_in">echo</span> “deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main” &gt; /etc/apt/sources.list.d/ros-latest.list</span><br></pre></td></tr></table></figure>
<h3 id="2-设置一下你的key"><a href="#2-设置一下你的key" class="headerlink" title="2. 设置一下你的key"></a>2. 设置一下你的key</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi: ~ $ sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers\.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</span><br></pre></td></tr></table></figure>
<h3 id="3-执行sudo-apt-get-update更新一下，然后执行安装命令"><a href="#3-执行sudo-apt-get-update更新一下，然后执行安装命令" class="headerlink" title="3. 执行sudo apt-get update更新一下，然后执行安装命令"></a>3. 执行sudo apt-get update更新一下，然后执行安装命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi: ~ $ sudo apt-get install ros-kinetic-desktop-full</span><br></pre></td></tr></table></figure>
<h3 id="4-初始化rosdep"><a href="#4-初始化rosdep" class="headerlink" title="4. 初始化rosdep"></a>4. 初始化rosdep</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi: ~ $ sudo rosdep init</span><br><span class="line">pi@raspberrypi: ~ $ rosdep update</span><br></pre></td></tr></table></figure>
<h3 id="5-如果你希望每次开启终端都可以使用ros环境的话，建议执行一下以下命令"><a href="#5-如果你希望每次开启终端都可以使用ros环境的话，建议执行一下以下命令" class="headerlink" title="5. 如果你希望每次开启终端都可以使用ros环境的话，建议执行一下以下命令"></a>5. 如果你希望每次开启终端都可以使用ros环境的话，建议执行一下以下命令</h3><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi: ~ $ <span class="built_in">echo</span> <span class="string">"source /opt/ros/kinetic/setup.bash"</span> &gt;&gt; ~/.bashrc</span><br><span class="line">pi@raspberrypi: ~ $ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="6-当然你也可以在每次启动终端后手动执行环境配置命令"><a href="#6-当然你也可以在每次启动终端后手动执行环境配置命令" class="headerlink" title="6. 当然你也可以在每次启动终端后手动执行环境配置命令"></a>6. 当然你也可以在每次启动终端后手动执行环境配置命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi: ~ \$ <span class="built_in">source</span> /opt/ros/kinetic/setup.bash</span><br></pre></td></tr></table></figure>

<p><strong>注: 如果你是用的是zsh终端，则应该讲第5步中的.bashrc文件更改为 .zshrc文件</strong></p>
]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转树莓派之树莓派安装jessie系统</title>
    <url>/2017/07/31/170731110822/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/76423140" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/76423140</a></p><h3 id="进入官网下载页面，下载你需要的镜像-下载链接"><a href="#进入官网下载页面，下载你需要的镜像-下载链接" class="headerlink" title="进入官网下载页面，下载你需要的镜像, 下载链接:"></a>进入官网下载页面，下载你需要的镜像, 下载链接:</h3><p><a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="noopener">https://www.raspberrypi.org/downloads/raspbian/</a><br><img src="https://img-blog.csdnimg.cn/20191027104250810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L295b3VuZ18yMDEy,size_16,color_FFFFFF,t_70" alt="树莓派下载页面"></p><h3 id="如上图所示，上面两个的jessie为带GUI桌面的，下面一个为纯命令行的，可以根据个人爱好选择"><a href="#如上图所示，上面两个的jessie为带GUI桌面的，下面一个为纯命令行的，可以根据个人爱好选择" class="headerlink" title="如上图所示，上面两个的jessie为带GUI桌面的，下面一个为纯命令行的，可以根据个人爱好选择"></a>如上图所示，上面两个的jessie为带GUI桌面的，下面一个为纯命令行的，可以根据个人爱好选择</h3><a id="more"></a>

<h3 id="如果是windows系统，只需要使用UtralISO之类的软件将镜像文件烧录到SD即可，如果是在Mac-OS或者Linux系统，请按照以下步骤"><a href="#如果是windows系统，只需要使用UtralISO之类的软件将镜像文件烧录到SD即可，如果是在Mac-OS或者Linux系统，请按照以下步骤" class="headerlink" title="如果是windows系统，只需要使用UtralISO之类的软件将镜像文件烧录到SD即可，如果是在Mac OS或者Linux系统，请按照以下步骤:"></a>如果是windows系统，只需要使用UtralISO之类的软件将镜像文件烧录到SD即可，如果是在Mac OS或者Linux系统，请按照以下步骤:</h3><ol>
<li>打开终端(ubuntu下的快捷键为Ctrl+Alt+T);</li>
<li>敲命令： df -h, 查看SD卡所在的分区， 如在Mac下我的SD卡分区为/dev/disk5,Ubuntu下我的SD卡分区为/dev/sdc,具体根据个人情况而定，只需要自己能够找到对应分区即可</li>
<li>使用umount命令卸载分区，Ubuntu下为”sudo umount /dev/sdc1”, macOS下为”diskutil umount /dev/disk5s1”</li>
<li>使用cd命令进入到你下载的jessie镜像所在目录，如我的下载目录在/home/oyoung/downloads,然后执行命令sudo dd bs=4m if=&lt;你的镜像文件&gt; of=&lt;你的SD对应的块设备&gt;，比如我上面提到的，Ubuntu下的/dev/sdc以及macOS下的/dev/disk5, 然后等待一段时间，具体视你的SD卡写入速度而定，毕竟镜像文件超过1G</li>
<li>以上步骤完成后，镜像的烧录工作基本完成，剩下的一些需要做的将SD卡插入树莓派并启动系统之后要做的系统设定工作，比如是否开启SSH，是否开启VNC，以及个别情况下需要设置系统启动屏幕分别率，一般触摸屏厂商的文档里面会提到如何设置</li>
</ol>
<h3 id="修改系统设置，-开机之后，使用HDMI将树莓派接上显示器，然后插入USB鼠标键盘，打开终端，输入sudo-raspi-config命令启动系统配置界面，具体配置自己摸索，然后连接上树莓派的无线网，通过ifconfig命令获取到树莓派的ip地址，记下来，后面一定会用到"><a href="#修改系统设置，-开机之后，使用HDMI将树莓派接上显示器，然后插入USB鼠标键盘，打开终端，输入sudo-raspi-config命令启动系统配置界面，具体配置自己摸索，然后连接上树莓派的无线网，通过ifconfig命令获取到树莓派的ip地址，记下来，后面一定会用到" class="headerlink" title="修改系统设置， 开机之后，使用HDMI将树莓派接上显示器，然后插入USB鼠标键盘，打开终端，输入sudo raspi-config命令启动系统配置界面，具体配置自己摸索，然后连接上树莓派的无线网，通过ifconfig命令获取到树莓派的ip地址，记下来，后面一定会用到"></a>修改系统设置， 开机之后，使用HDMI将树莓派接上显示器，然后插入USB鼠标键盘，打开终端，输入sudo raspi-config命令启动系统配置界面，具体配置自己摸索，然后连接上树莓派的无线网，通过ifconfig命令获取到树莓派的ip地址，记下来，后面一定会用到</h3>]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下搭建openGL开发环境</title>
    <url>/2017/07/31/170731105358/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/76422589" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/76422589</a></p><h2 id="1-下载并安装GLFW"><a href="#1-下载并安装GLFW" class="headerlink" title="1. 下载并安装GLFW"></a>1. 下载并安装GLFW</h2><p>这里给个官网链接: <a href="http://www.glfw.org/download.html" target="_blank" rel="noopener">http://www.glfw.org/download.html</a><br>打开该页面后， 点击Source Package后会启动下载，下载完成后解压到你自己指定的目录<br>，比如笔者的解压路径为: ~/Downloads/glfw-3.2.1<br>打开终端，执行以下命令:</p><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ <span class="built_in">cd</span> ~/Downloads/glfw-3.2.1</span><br><span class="line">~$ cmake -Bbuild -H. -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> </span><br><span class="line">~$ sudo cmake --build build --target install</span><br></pre></td></tr></table></figure>
<h2 id="2-下载安装GLEW"><a href="#2-下载安装GLEW" class="headerlink" title="2. 下载安装GLEW"></a>2. 下载安装GLEW</h2><p>下载链接: <a href="http://glew.sourceforge.net/index.html" target="_blank" rel="noopener">http://glew.sourceforge.net/index.html</a><br>打开页面，点击Source后面的ZIP 或者TGZ, 下载源码压缩包并解压<br>比如笔者解压目录为: ~/Downloads/glew-2.0.0<br>继续在终端中执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ <span class="built_in">cd</span> ~/Downloads/glew-2.0.0</span><br><span class="line">~$ make GLEW_DEST=/usr/<span class="built_in">local</span> -j4</span><br><span class="line">~$ sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="3-使用Xcode新建C-Command-Line项目-并在项目的Build-Setting中设置User-Header-Search-Paths-添加一个-usr-local-include-和Library-Search-Paths-添加一个-usr-local-lib"><a href="#3-使用Xcode新建C-Command-Line项目-并在项目的Build-Setting中设置User-Header-Search-Paths-添加一个-usr-local-include-和Library-Search-Paths-添加一个-usr-local-lib" class="headerlink" title="3. 使用Xcode新建C++ Command Line项目,并在项目的Build Setting中设置User Header Search Paths(添加一个/usr/local/include)和Library Search Paths(添加一个/usr/local/lib)"></a>3. 使用Xcode新建C++ Command Line项目,并在项目的Build Setting中设置User Header Search Paths(添加一个/usr/local/include)和Library Search Paths(添加一个/usr/local/lib)</h2><h2 id="4-在Build-Phases的Link-Library-With-Libraries里面添加依赖库"><a href="#4-在Build-Phases的Link-Library-With-Libraries里面添加依赖库" class="headerlink" title="4. 在Build Phases的Link Library With Libraries里面添加依赖库"></a>4. 在Build Phases的Link Library With Libraries里面添加依赖库</h2><p>其中以下的依赖库为必需的:</p>
<pre><code>IOKit.framework
CoreVideo.framework
Cocoa.framework
OpenGL.framework
libglfw3.a
libGLEW.a</code></pre><h3 id="5-在main函数中调用glfwInit-编译，看是否报错，-没有报错则表示所需要的库都已经引入-安装环境就搭建好了，接下来你就可以尽情享受openGL带来的乐趣了"><a href="#5-在main函数中调用glfwInit-编译，看是否报错，-没有报错则表示所需要的库都已经引入-安装环境就搭建好了，接下来你就可以尽情享受openGL带来的乐趣了" class="headerlink" title="5. 在main函数中调用glfwInit(); 编译，看是否报错， 没有报错则表示所需要的库都已经引入,安装环境就搭建好了，接下来你就可以尽情享受openGL带来的乐趣了"></a>5. 在main函数中调用glfwInit(); 编译，看是否报错， 没有报错则表示所需要的库都已经引入,安装环境就搭建好了，接下来你就可以尽情享受openGL带来的乐趣了</h3>]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>C#调用C/C++的dll须知</title>
    <url>/2017/01/20/170120143234/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/54631165" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/54631165</a></p><h2 id="1-C-类型与C-C-类型的对应关系"><a href="#1-C-类型与C-C-类型的对应关系" class="headerlink" title="1. C#类型与C/C++类型的对应关系"></a>1. C#类型与C/C++类型的对应关系</h2><h3 id="基本数据类型-C-lt-—-gt-C-C"><a href="#基本数据类型-C-lt-—-gt-C-C" class="headerlink" title="基本数据类型(C# &lt;—&gt; C/C++)"></a>基本数据类型(C# &lt;—&gt; C/C++)</h3><ul>
<li>System.Int32,int &lt;—&gt; int, long</li>
<li>System.Int64,int64 &lt;—&gt; long long, __int64</li>
<li>System.Char, char &lt;—&gt; char, byte, unsigned char</li>
<li>System.Int16, short &lt;—&gt; short</li>
<li>System.UInt32, uint &lt;—&gt; unsigned int, unsigned long</li>
<li>System.UInt16, ushort &lt;—&gt; unsigned short, DWORD</li>
<li>System.String, string &lt;—&gt; char[], char *, const char *</li>
<li>System.IntPtr &lt;—&gt; void *, [Type]* </li>
<li>Sytem.Boolean, bool &lt;—&gt; bool, BOOL</li>
</ul><a id="more"></a>

<h2 id="2-C-C-函数参数类型与C-类型对应关系"><a href="#2-C-C-函数参数类型与C-类型对应关系" class="headerlink" title="2.C/C++函数参数类型与C#类型对应关系"></a>2.C/C++函数参数类型与C#类型对应关系</h2><pre><code>① 基本的数据类型对应关系与1相同，但是也有一些不一样的地方
② const char * 一般作为输入参数， C#直接使用string类型即可(StringBuilder也可以)
③ char *作为输入参数的时候， C#需要使用ref string类型或者StringBuilder类型
④ 结构体指针做输入参数的时候， C#一般使用ref + 对应的结构体类型</code></pre><h2 id="3-C-C-结构体与C-结构体的成员类型对应关系"><a href="#3-C-C-结构体与C-结构体的成员类型对应关系" class="headerlink" title="3. C/C++结构体与C#结构体的成员类型对应关系"></a>3. C/C++结构体与C#结构体的成员类型对应关系</h2><h3 id="A-如果C-C-结构体成员类型是基本数据类型，-C-中对应的结构体成员类型使用1中的对应关系即可，-如"><a href="#A-如果C-C-结构体成员类型是基本数据类型，-C-中对应的结构体成员类型使用1中的对应关系即可，-如" class="headerlink" title="A. 如果C/C++结构体成员类型是基本数据类型， C#中对应的结构体成员类型使用1中的对应关系即可， 如:"></a>A. 如果C/C++结构体成员类型是基本数据类型， C#中对应的结构体成员类型使用1中的对应关系即可， 如:</h3><p>C/C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Some</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> character;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">32</span>];	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C#代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Some</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">char</span> charactor;</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.ByValTStr, SizeConst=32)</span>]</span><br><span class="line">	<span class="keyword">string</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-如果C-C-的结构体成员中包含的成员仍然是结构体-单个，非数组-则对应的C-结构体只需要同样包含结构体，-如："><a href="#B-如果C-C-的结构体成员中包含的成员仍然是结构体-单个，非数组-则对应的C-结构体只需要同样包含结构体，-如：" class="headerlink" title="B. 如果C/C++的结构体成员中包含的成员仍然是结构体(单个，非数组), 则对应的C#结构体只需要同样包含结构体， 如："></a>B. 如果C/C++的结构体成员中包含的成员仍然是结构体(单个，非数组), 则对应的C#结构体只需要同样包含结构体， 如：</h3><p>C/C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line">	<span class="keyword">int</span> otherNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的C#代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> B</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> A a;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> otherNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-如果C-C-结构体成员中包含数组-长度固定-，则C-结构体中也使用数组对应的类型，-如："><a href="#C-如果C-C-结构体成员中包含数组-长度固定-，则C-结构体中也使用数组对应的类型，-如：" class="headerlink" title="C. 如果C/C++结构体成员中包含数组(长度固定)，则C#结构体中也使用数组对应的类型， 如："></a>C. 如果C/C++结构体成员中包含数组(长度固定)，则C#结构体中也使用数组对应的类型， 如：</h3><p>C/C++代码<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> numbers[<span class="number">10</span>];</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">alist</span>[5];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>对应的C#代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> A </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> B</span><br><span class="line">&#123;</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.ByValArray, SizeConst=10, ArraySubType=UnmanagedType.SysInt)</span>]	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] numbers;</span><br><span class="line">	[<span class="meta">MarshalAs(UnmanagedType.ByValArray, SizeConst=10, ArraySubType=UnmanagedType.Struct)</span>]</span><br><span class="line">	<span class="keyword">public</span> A[] alist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-如果C-C-的结构体成员中包含另一个结构体的指针，C-对应的结构体中一律使用IntPtr类型，-如："><a href="#D-如果C-C-的结构体成员中包含另一个结构体的指针，C-对应的结构体中一律使用IntPtr类型，-如：" class="headerlink" title="D. 如果C/C++的结构体成员中包含另一个结构体的指针，C#对应的结构体中一律使用IntPtr类型， 如："></a>D. 如果C/C++的结构体成员中包含另一个结构体的指针，C#对应的结构体中一律使用IntPtr类型， 如：</h3><p>C/C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> tag;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">pA</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的C#代码</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> B</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> tag;</span><br><span class="line">	<span class="keyword">public</span> IntPtr pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然后在使用的时候需要用到Marshal类的StructureToPtr和PtrToStructure方法进行转换<br>转换方法如下：<br>（1）结构体转换成IntPtr</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">IntPtr pA= Marshal.AllocHGlobal(Marshal.SizeOf(a));</span><br><span class="line">Marshal.StructureToPtr(a, pA, <span class="literal">false</span>);</span><br><span class="line">b.pA = pA;</span><br></pre></td></tr></table></figure>
<p>（2）IntPtr 转换成结构体</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">//...省略中间的操作过程</span></span><br><span class="line">A aInB = (A)Marshal.PtrToStructure(b.pA, <span class="keyword">typeof</span>(A))</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">A aInB = <span class="keyword">new</span> A();</span><br><span class="line">Marshal.PtrToStructure(b.pA, aInB);</span><br></pre></td></tr></table></figure>
<h2 id="4-关于类型转换中的数组长度"><a href="#4-关于类型转换中的数组长度" class="headerlink" title="4. 关于类型转换中的数组长度"></a>4. 关于类型转换中的数组长度</h2><ul>
<li><p>C/C++中，如果是char类型的数组（一般表示最大长度不超过某个数字的字符串），那么在进行参数传递的时候，如果C#中的string字符串字节数超过了C/C++中的最大字节数，则会发生截断， 如C/C++中， char name[3]; 但是在C#中却使用了string name = “Jack”,实际传到C/C++中， name中的内容为“Ja”,多余的部分没有填充进来</p>
</li>
<li><p>C/C++中使用的数组为定长数组，在参数传递过程中，如果C#中使用的数组长度比C/C++中数组长度短，则会发生System.ArgumentException异常，提示“未能封送类型，因为嵌入数组实例的长度与布局中声明的长度不匹配“(C#的string到C/C++的char 数组不会，但是C#char[]到C/C++的char数组会有此异常)，因此, 我们要定义相同长度的数组才能正常工作（C#数组长度更大的时候，会忽略多余的部分）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>从C到C++看面相对象(深入了解C++的成员函数)</title>
    <url>/2017/01/18/170118150250/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/54601314" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/54601314</a></p><p> 我们都知道C是一门面相过程的语言，在C的世界里是没有面相对象这个概念的，但是C语言为我们提供的神兵利器，仍旧可以让我们使用面相对象的思维方式<br>在C语言里，我们每做一个操作，都需要写一个函数，但是该函数都是过程化的，但是我们有两种神兵利器，一个叫指针，一个叫结构体<br>为什么这么说呢？<br>面相对象的最基本的功能就是对数据的封装，在C语言的世界里，我们有结构体这个法宝，同样可以将数据打包整整体，然后通过指针的方式，将结构体作为参数在函数中进行传递<br>举个例子</p><a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">32</span>]; <span class="comment">//书名</span></span><br><span class="line">	<span class="keyword">char</span> author[<span class="number">32</span>]; <span class="comment">//作者名</span></span><br><span class="line">	<span class="keyword">int</span> total; <span class="comment">//总页数</span></span><br><span class="line">	<span class="keyword">int</span> price;<span class="comment">//价格</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">Book</span>;</span></span><br><span class="line"><span class="comment">//初始化一本书</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book_init</span><span class="params">(Book *book, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *author, <span class="keyword">int</span> total, <span class="keyword">int</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(book-&gt;name, name);</span><br><span class="line">	<span class="built_in">strcpy</span>(book-&gt;author, author);</span><br><span class="line">	book-&gt;total = total;</span><br><span class="line">	book-&gt;price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book_update_price</span><span class="params">(Book *book, <span class="keyword">int</span> newPrice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	book-&gt;price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的例子很简单，初始化一本书以及更新书价，在使用的时候，我们只需要像以下方式调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Book book;</span><br><span class="line">book_init(&amp;book, <span class="string">"WPF 编程宝典"</span>, <span class="string">"Matthew MacDonald"</span>, <span class="number">934</span>, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">book_update_price(&amp;book, <span class="number">100</span>); <span class="comment">//降价</span></span><br></pre></td></tr></table></figure>
<p>以上的这些使用的都是面相过程的思维。<br>所谓面向过程编程，就好比“让某某去做某事”，而面向对象呢，就好比“某某去做某事”。从字面意思来看，面向过程貌似多了个“高级领导”，而面向对象显得更自由。<br>###我们再变一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">char</span> author[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">int</span> price;</span><br><span class="line">	<span class="keyword">void</span> (*init)(Book *book, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *author, <span class="keyword">int</span> price);</span><br><span class="line">	<span class="keyword">void</span> (*update_price)(Book *book, <span class="keyword">int</span> newPrice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一本书</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book_init</span><span class="params">(Book *book, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *author, <span class="keyword">int</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(book-&gt;name, name);</span><br><span class="line">	<span class="built_in">strcpy</span>(book-&gt;author, author);</span><br><span class="line">	book-&gt;total = total;</span><br><span class="line">	book-&gt;price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book_update_price</span><span class="params">(Book *book, <span class="keyword">int</span> newPrice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	book-&gt;price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一本书</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book_create</span><span class="params">(Book *book)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	book-&gt;init = book_init;</span><br><span class="line">	book-&gt;update_price = book_update_price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你就可以像以下一样使用了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Book book;</span><br><span class="line">book_create(&amp;book);</span><br><span class="line"></span><br><span class="line">book.init(&amp;book, <span class="string">"WPF 编程宝典"</span>, <span class="string">"Matthew MacDonald"</span>, <span class="number">128</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">book.update_price(&amp;book, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>使用这种方式来调用，看起来有了一种“书做了某某事”的面向对象的错觉<br>###C++正是借鉴了这一点，从而产生了Class（类）<br>当我们定义一个class的时候，我们自己定义的成员函数就使用了我们上面的思想，参考如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">char</span> author[<span class="number">32</span>;</span><br><span class="line">	<span class="keyword">int</span> price;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *author, <span class="keyword">int</span> price)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;author, author);</span><br><span class="line">		<span class="keyword">this</span>-&gt;price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updatePrice</span><span class="params">(<span class="keyword">int</span> price)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;price = price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们是用起来显得更简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Book book;</span><br><span class="line">book.init(<span class="string">"WPF 编程宝典"</span>, <span class="string">"Matthew MacDonald"</span>, <span class="number">128</span>):</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">book.updatePrice(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>看起来与我们使用C语言模仿的面向对象是不是很像？<br>接下来我们注意到一个关键字this, 指的是调用函数的某个对象，谁调用了，this指的就是谁，上面的book调用init和updatePrice的时候，this指的就是book这个对象。</p>
<p>我想你应该明白了，C++的面向对象，就是使用了我们的上述模拟面向对象的思维，然后C++自己将对象本身作为一个隐含的参数传递给了我们的成员函数，当然，这些并不包括C++面向对象中更强大的继承和多态。<br>到此我觉得你应该明白了C++成员函数与普通函数之间的区别以及其内部的原理。<br>再看下面代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123; <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">makeTest</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"我在考试"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">appear</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"My name is "</span>&lt;&lt;name&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在看如下调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student *pStu;</span><br><span class="line"></span><br><span class="line">pStu-&gt;makeTest(); <span class="comment">// ①</span></span><br><span class="line">pStu-&gt;appear(); <span class="comment">// ②</span></span><br></pre></td></tr></table></figure>
<p>很多人都会想到，pStu是一个未初始化的变量，以上①②两种调用都会导致崩溃。再仔细想想看，真的是这样吗？<br>比较细心的同学会发现，在某些编译器上运行，我们却可以看到①调用后的打印信息，而运行②以后，程序崩溃掉了，我想细心的你应该知道这是什么原因了。<br>很简单，我们在①处调用的makeTest()函数，翻译成C语言的形式应该是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeTest</span><span class="params">(Student *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//打印“我在考试”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeTest(pStu);</span><br></pre></td></tr></table></figure>
<p>在代码里面，pStu虽然没有初始化，但是在上面的C语言版的makeTest中，我们并没有使用到this这个参数，所以即使这个参数指针是一个野指针或者空指针，都不会出现崩溃现象，但是对于②处的调用，使用的appear()函数中使用到了this, 也就是说，此时的this是一个未初始化的指针（我们称为野指针，不是空指针），这个指针指向什么地方我们并不知道，可能是没有权限操作的一块内存，也可能正好是空指针，也可能是已经分配的某个内存</p>
<p>我们再做一个小实验</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> != <span class="literal">nullptr</span>) <span class="comment">//C++11中引入的nullptr， 表示空指针，感兴趣的可以自己去多多了解C++11</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"我不是空的"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"我是空的"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line">	Test *p = <span class="literal">nullptr</span>; <span class="comment">//设置初始值，防止使用未初始化指针	</span></span><br><span class="line">	p-&gt;test();</span><br><span class="line">	</span><br><span class="line">	p = &amp;t;</span><br><span class="line">	p-&gt;test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你能猜出最终的打印信息吗？(</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>针对第三方SDK中不恰当的char *类型的几点看法</title>
    <url>/2017/01/10/170110173549/</url>
    <content><![CDATA[<p>原文链接:<br><a href="https://blog.csdn.net/oyoung_2012/article/details/54315963" target="_blank" rel="noopener">https://blog.csdn.net/oyoung_2012/article/details/54315963</a></p><h2 id="很多时候，会遇到第三方接口中本来需要使用const-char-类型参数的时候，却使用了char-类型，以至于我们原本可以使用如someFunction-“some”-却编译报错（如某康的SDK）"><a href="#很多时候，会遇到第三方接口中本来需要使用const-char-类型参数的时候，却使用了char-类型，以至于我们原本可以使用如someFunction-“some”-却编译报错（如某康的SDK）" class="headerlink" title="很多时候，会遇到第三方接口中本来需要使用const char *类型参数的时候，却使用了char *类型，以至于我们原本可以使用如someFunction(“some”), 却编译报错（如某康的SDK）"></a>很多时候，会遇到第三方接口中本来需要使用const char *类型参数的时候，却使用了char *类型，以至于我们原本可以使用如someFunction(“some”), 却编译报错（如某康的SDK）</h2><a id="more"></a>
<p>###针对以上的这种问题，我们可以在对第三方SDK进行本地封装的时候对参数类型进行修改，比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SDK 头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Login</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, <span class="keyword">char</span> *userName, <span class="keyword">char</span> *password)</span></span>; <span class="comment">//这里本来应该要使用const char *类型代替char *类型，因为该函数根本不会修改参数的值，但是基于某某程序员的某某原因，却没有这样使用，以至于我们调用该接口时，并不能像以下方式调用</span></span><br><span class="line"></span><br><span class="line">Login(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>, <span class="string">"admin"</span>, <span class="string">"admin"</span>); <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们应该将其进行正确参数类型的封装</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDK</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *userName, <span class="keyword">const</span> <span class="keyword">char</span> *password)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">transform</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pChar)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SDK::login(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *userName, <span class="keyword">const</span> <span class="keyword">char</span> *password) &#123;</span><br><span class="line">		<span class="keyword">char</span> *newIp = transform(ip);</span><br><span class="line">		<span class="keyword">char</span> *newUserName = transform(userName);</span><br><span class="line">		<span class="keyword">char</span> *newPassword = transform(password);</span><br><span class="line">		Login(newIp, port, newUserName, newPassword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * SDK::transform(<span class="keyword">const</span> <span class="keyword">char</span> *pChar) &#123;</span><br><span class="line">	<span class="comment">//方案1，使用const_cast</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(pChar);</span><br><span class="line">	<span class="comment">//方案2，使用联合体</span></span><br><span class="line">	<span class="keyword">union</span> &#123; <span class="keyword">char</span> *p; <span class="keyword">const</span> <span class="keyword">char</span> *q;&#125; t;</span><br><span class="line">	t.q = pChar;</span><br><span class="line">	<span class="keyword">return</span> t.p;</span><br><span class="line">	<span class="comment">//方案3， 利用整数类型</span></span><br><span class="line">	<span class="keyword">int</span> address = (<span class="keyword">int</span>)pChar;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">char</span> *)address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
